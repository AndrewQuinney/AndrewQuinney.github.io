<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bezier Geometry: bezier_geometry::BezierCurveQ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bezier Geometry
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bezier_geometry</b></li><li class="navelem"><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classbezier__geometry_1_1_bezier_curve_q-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">bezier_geometry::BezierCurveQ Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A quadratic Bezier Curve.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_bezier_curve_q_8hpp_source.html">BezierCurveQ.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_c_w_angle_interval.html">CWAngleInterval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single interval on a curve representing a direction of rotation about a fulcrum.  <a href="structbezier__geometry_1_1_bezier_curve_q_1_1_c_w_angle_interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_rotate_against_result.html">RotateAgainstResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a 'rotate against' operation.  <a href="structbezier__geometry_1_1_bezier_curve_q_1_1_rotate_against_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_shift_against_result.html">ShiftAgainstResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a 'shift against' operation.  <a href="structbezier__geometry_1_1_bezier_curve_q_1_1_shift_against_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a80671c0640422512218ad5aa3b8e0ec0" id="r_a80671c0640422512218ad5aa3b8e0ec0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80671c0640422512218ad5aa3b8e0ec0">BezierCurveQ</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;s, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;e, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;c)</td></tr>
<tr class="memdesc:a80671c0640422512218ad5aa3b8e0ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of a curve using the standard parameters.  <br /></td></tr>
<tr class="separator:a80671c0640422512218ad5aa3b8e0ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b82a2c5f313fff378b1d295b2354d45" id="r_a9b82a2c5f313fff378b1d295b2354d45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b82a2c5f313fff378b1d295b2354d45">curveIntersectionBlocksRotate</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;myParam, const <a class="el" href="structbezier__geometry_1_1_crits_and_values.html">CritsAndValues</a>&lt; 5 &gt; &amp;myDistanceCrits, const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;input, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;inputParam, const <a class="el" href="structbezier__geometry_1_1_crits_and_values.html">CritsAndValues</a>&lt; 5 &gt; &amp;inputDistanceCrits, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;fulcrum, const bool clockwise, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;outputBlockedCWVerticalAngleStart, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;outputBlockedCWVerticalAngleEnd, bool &amp;outputAtMyCrit, bool &amp;outputAtInputCrit) const</td></tr>
<tr class="memdesc:a9b82a2c5f313fff378b1d295b2354d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an intersection will block a rotation.  <br /></td></tr>
<tr class="separator:a9b82a2c5f313fff378b1d295b2354d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff81ffbea7ad8cc9d2edaaaaa6593c0" id="r_a7ff81ffbea7ad8cc9d2edaaaaa6593c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ff81ffbea7ad8cc9d2edaaaaa6593c0">curveIntersectionBlocksShift</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;myParam, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;slope, bool right, bool up, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;inputParam, const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;input, const bool tolerateSmallMagnitudeOverlap, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;outputBlockedCWVerticalAngleStart, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;outputBlockedCWVerticalAngleEnd, bool &amp;outputAtMyCrit, bool &amp;outputAtInputCrit) const</td></tr>
<tr class="memdesc:a7ff81ffbea7ad8cc9d2edaaaaa6593c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an intersection will block a straight line movement.  <br /></td></tr>
<tr class="separator:a7ff81ffbea7ad8cc9d2edaaaaa6593c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19754b3703256ecf261fe2407c520e95" id="r_a19754b3703256ecf261fe2407c520e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19754b3703256ecf261fe2407c520e95">getConcavityIndicator</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;parameter) const</td></tr>
<tr class="memdesc:a19754b3703256ecf261fe2407c520e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a point that indicates the direction of this curve's concavity.  <br /></td></tr>
<tr class="separator:a19754b3703256ecf261fe2407c520e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c5f027b6caffcbd7cd41fc9b1beae" id="r_ac27c5f027b6caffcbd7cd41fc9b1beae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac27c5f027b6caffcbd7cd41fc9b1beae">getConcavitySlope</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;parameter) const</td></tr>
<tr class="memdesc:ac27c5f027b6caffcbd7cd41fc9b1beae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a numeric value indicating how 'curved' this curve is at a given point.  <br /></td></tr>
<tr class="separator:ac27c5f027b6caffcbd7cd41fc9b1beae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490ccf7dc1b60fcca2d96ca5b6b53edc" id="r_a490ccf7dc1b60fcca2d96ca5b6b53edc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a490ccf7dc1b60fcca2d96ca5b6b53edc">getControl</a> () const</td></tr>
<tr class="memdesc:a490ccf7dc1b60fcca2d96ca5b6b53edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single control point for this curve.  <br /></td></tr>
<tr class="separator:a490ccf7dc1b60fcca2d96ca5b6b53edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdbf2ac178f1682afb54c3245ab976d" id="r_a9fdbf2ac178f1682afb54c3245ab976d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fdbf2ac178f1682afb54c3245ab976d">getCurveDistanceParams</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;fulcrum, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;distance, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;startParam, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;endParam) const</td></tr>
<tr class="memdesc:a9fdbf2ac178f1682afb54c3245ab976d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters for this curve for a given distance from a point.  <br /></td></tr>
<tr class="separator:a9fdbf2ac178f1682afb54c3245ab976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921886bfda9ca6cd010d0c1121a2e6b3" id="r_a921886bfda9ca6cd010d0c1121a2e6b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a921886bfda9ca6cd010d0c1121a2e6b3">getCWAngleIntervals</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;fulcrum, <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_c_w_angle_interval.html">CWAngleInterval</a>, 4 &gt; &amp;outputFirstSet, <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_c_w_angle_interval.html">CWAngleInterval</a>, 4 &gt; &amp;outputSecondSet) const</td></tr>
<tr class="memdesc:a921886bfda9ca6cd010d0c1121a2e6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a set of intervals for this curve for its angle ranges about a fulcrum.  <br /></td></tr>
<tr class="separator:a921886bfda9ca6cd010d0c1121a2e6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09ffde9fe0af6ca9abbde5592ba7963" id="r_ad09ffde9fe0af6ca9abbde5592ba7963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad09ffde9fe0af6ca9abbde5592ba7963">getDirectionIndicator</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;parameter) const</td></tr>
<tr class="memdesc:ad09ffde9fe0af6ca9abbde5592ba7963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a point that is on a tangential straight line from this curve at a parameter.  <br /></td></tr>
<tr class="separator:ad09ffde9fe0af6ca9abbde5592ba7963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0267507b857ef41a8dca7851a5570123" id="r_a0267507b857ef41a8dca7851a5570123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbezier__geometry_1_1_crits_and_values.html">CritsAndValues</a>&lt; 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0267507b857ef41a8dca7851a5570123">getDistanceCritsAndValues</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;input) const</td></tr>
<tr class="memdesc:a0267507b857ef41a8dca7851a5570123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this curve's distance intervals from a point.  <br /></td></tr>
<tr class="separator:a0267507b857ef41a8dca7851a5570123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe322f0f81d52cbbdf667aef21b8628" id="r_a8fe322f0f81d52cbbdf667aef21b8628"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fe322f0f81d52cbbdf667aef21b8628">getMaxXExtent</a> () const</td></tr>
<tr class="memdesc:a8fe322f0f81d52cbbdf667aef21b8628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest X-coordinate that any point on this curve occupies.  <br /></td></tr>
<tr class="separator:a8fe322f0f81d52cbbdf667aef21b8628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788f2e192f2f5da2c0a782b768e24159" id="r_a788f2e192f2f5da2c0a782b768e24159"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a788f2e192f2f5da2c0a782b768e24159">getMaxXPara</a> () const</td></tr>
<tr class="memdesc:a788f2e192f2f5da2c0a782b768e24159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter for the highest X-coordinate that any point on this curve occupies.  <br /></td></tr>
<tr class="separator:a788f2e192f2f5da2c0a782b768e24159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bef3e008ed0b013d28c015d7ece808" id="r_ae1bef3e008ed0b013d28c015d7ece808"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1bef3e008ed0b013d28c015d7ece808">getMaxYExtent</a> () const</td></tr>
<tr class="memdesc:ae1bef3e008ed0b013d28c015d7ece808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest Y-coordinate that any point on this curve occupies.  <br /></td></tr>
<tr class="separator:ae1bef3e008ed0b013d28c015d7ece808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56d416f16e0aa1138c5c52492c4544d" id="r_aa56d416f16e0aa1138c5c52492c4544d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa56d416f16e0aa1138c5c52492c4544d">getMaxYPara</a> () const</td></tr>
<tr class="memdesc:aa56d416f16e0aa1138c5c52492c4544d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter for the highest Y-coordinate that any point on this curve occupies.  <br /></td></tr>
<tr class="separator:aa56d416f16e0aa1138c5c52492c4544d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11b916bf16435496899009211c5da0b" id="r_ac11b916bf16435496899009211c5da0b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac11b916bf16435496899009211c5da0b">getMinXExtent</a> () const</td></tr>
<tr class="memdesc:ac11b916bf16435496899009211c5da0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lowest X-coordinate that any point on this curve occupies.  <br /></td></tr>
<tr class="separator:ac11b916bf16435496899009211c5da0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918cc69a549367fd93421cd19f46abf" id="r_ac918cc69a549367fd93421cd19f46abf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac918cc69a549367fd93421cd19f46abf">getMinXPara</a> () const</td></tr>
<tr class="memdesc:ac918cc69a549367fd93421cd19f46abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter for the lowest X-coordinate that any point on this curve occupies.  <br /></td></tr>
<tr class="separator:ac918cc69a549367fd93421cd19f46abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9385195b6a3214b90d86569b54f8d388" id="r_a9385195b6a3214b90d86569b54f8d388"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9385195b6a3214b90d86569b54f8d388">getMinYExtent</a> () const</td></tr>
<tr class="memdesc:a9385195b6a3214b90d86569b54f8d388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lowest Y-coordinate that any point on this curve occupies.  <br /></td></tr>
<tr class="separator:a9385195b6a3214b90d86569b54f8d388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9310081f4bd9ec2a0c615ddb5107da07" id="r_a9310081f4bd9ec2a0c615ddb5107da07"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9310081f4bd9ec2a0c615ddb5107da07">getMinYPara</a> () const</td></tr>
<tr class="memdesc:a9310081f4bd9ec2a0c615ddb5107da07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameter for the lowest Y-coordinate that any point on this curve occupies.  <br /></td></tr>
<tr class="separator:a9310081f4bd9ec2a0c615ddb5107da07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d7ed205c84779a2acae08561087ad7" id="r_a09d7ed205c84779a2acae08561087ad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbezier__geometry_1_1_crits_and_values.html">CritsAndValues</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09d7ed205c84779a2acae08561087ad7">getPerpendicularMagnitudeCritsAndValues</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;slope) const</td></tr>
<tr class="memdesc:a09d7ed205c84779a2acae08561087ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ranges of 'perpendicular magnitudes' that this curve exists in for a given slope.  <br /></td></tr>
<tr class="separator:a09d7ed205c84779a2acae08561087ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fd868c0fff56f654656df15486e4f7" id="r_aa9fd868c0fff56f654656df15486e4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9fd868c0fff56f654656df15486e4f7">maxDistance</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;input) const</td></tr>
<tr class="memdesc:aa9fd868c0fff56f654656df15486e4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the point on this curve that is farthest from the input point.  <br /></td></tr>
<tr class="separator:aa9fd868c0fff56f654656df15486e4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a45682c2c56345d2c804e06ffe1c5fe" id="r_a0a45682c2c56345d2c804e06ffe1c5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a45682c2c56345d2c804e06ffe1c5fe">maxDistance</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;input, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;minParam, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;maxParam) const</td></tr>
<tr class="memdesc:a0a45682c2c56345d2c804e06ffe1c5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the point on this curve that is farthest from the input point within a parameter range.  <br /></td></tr>
<tr class="separator:a0a45682c2c56345d2c804e06ffe1c5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b496ee406174cd2ff2be869495bdea" id="r_a44b496ee406174cd2ff2be869495bdea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44b496ee406174cd2ff2be869495bdea">minDistance</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;input) const</td></tr>
<tr class="memdesc:a44b496ee406174cd2ff2be869495bdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the point on this curve that is closest to the input point.  <br /></td></tr>
<tr class="separator:a44b496ee406174cd2ff2be869495bdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c86f9ae101dd0d4f67942db1453e2c" id="r_a25c86f9ae101dd0d4f67942db1453e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25c86f9ae101dd0d4f67942db1453e2c">minDistance</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;input, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;minParam, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;maxParam) const</td></tr>
<tr class="memdesc:a25c86f9ae101dd0d4f67942db1453e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the point on this curve that is closest to the input point within a parameter range.  <br /></td></tr>
<tr class="separator:a25c86f9ae101dd0d4f67942db1453e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b849e49e2ba1fe096f33294006e766" id="r_ad4b849e49e2ba1fe096f33294006e766"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4b849e49e2ba1fe096f33294006e766">operator==</a> (const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;input) const</td></tr>
<tr class="memdesc:ad4b849e49e2ba1fe096f33294006e766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if this curve is sufficiently close to the input curve to be considered equivalent.  <br /></td></tr>
<tr class="separator:ad4b849e49e2ba1fe096f33294006e766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bd12a9a615e02c6f81b8b5cdc87f77" id="r_ab9bd12a9a615e02c6f81b8b5cdc87f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9bd12a9a615e02c6f81b8b5cdc87f77">paramForPoint</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;input) const</td></tr>
<tr class="memdesc:ab9bd12a9a615e02c6f81b8b5cdc87f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Bezier parameter for this curve that will result in a given point.  <br /></td></tr>
<tr class="separator:ab9bd12a9a615e02c6f81b8b5cdc87f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a46ae9d4dd7686de1999f0d2eb56da0" id="r_a8a46ae9d4dd7686de1999f0d2eb56da0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a46ae9d4dd7686de1999f0d2eb56da0">pointShiftAgainstParams</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;input, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;slope, bool skipIntersections) const</td></tr>
<tr class="memdesc:a8a46ae9d4dd7686de1999f0d2eb56da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters for this curve that are along a slope from a point.  <br /></td></tr>
<tr class="separator:a8a46ae9d4dd7686de1999f0d2eb56da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fe814422473d9cf08b2e80a264772a" id="r_a78fe814422473d9cf08b2e80a264772a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; std::pair&lt; <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &gt;, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78fe814422473d9cf08b2e80a264772a">pointsOfIntersection</a> (const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;input) const</td></tr>
<tr class="memdesc:a78fe814422473d9cf08b2e80a264772a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the points of intersection for this and another curve.  <br /></td></tr>
<tr class="separator:a78fe814422473d9cf08b2e80a264772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289c5b1b42462906b631d58946a696b6" id="r_a289c5b1b42462906b631d58946a696b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a289c5b1b42462906b631d58946a696b6">rateOfChangeAtParam</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;parameter) const</td></tr>
<tr class="memdesc:a289c5b1b42462906b631d58946a696b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get this curve's slope at a parameter.  <br /></td></tr>
<tr class="separator:a289c5b1b42462906b631d58946a696b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2139a4bde1e4dfce10f5b6d295093aa6" id="r_a2139a4bde1e4dfce10f5b6d295093aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2139a4bde1e4dfce10f5b6d295093aa6">rotate</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;fulcrum, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;angle) const</td></tr>
<tr class="memdesc:a2139a4bde1e4dfce10f5b6d295093aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the curve that results from rotating this curve.  <br /></td></tr>
<tr class="separator:a2139a4bde1e4dfce10f5b6d295093aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551b65207eb94582d96cf3a6d02f8e2c" id="r_a551b65207eb94582d96cf3a6d02f8e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a551b65207eb94582d96cf3a6d02f8e2c">rotateAgainst</a> (const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;input, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;fulcrum, bool clockwise, <a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_rotate_against_result.html">RotateAgainstResult</a> &amp;output) const</td></tr>
<tr class="memdesc:a551b65207eb94582d96cf3a6d02f8e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the angle that this curve can be rotated until it 'hits' the input curve.  <br /></td></tr>
<tr class="separator:a551b65207eb94582d96cf3a6d02f8e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67ac069d2ebfece00d7ae319389d6e7" id="r_ab67ac069d2ebfece00d7ae319389d6e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab67ac069d2ebfece00d7ae319389d6e7">rotateAgainstCircleArc</a> (const CircleArc &amp;<a class="el" href="#af8c6e78e350b81a7239ae7a2436b8885">circleArc</a>, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;fulcrum, bool clockwise, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;outputAngle, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;outputParam, <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;outputCirclePoint) const</td></tr>
<tr class="memdesc:ab67ac069d2ebfece00d7ae319389d6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the angle that this curve can be rotated until it 'hits' the input arc.  <br /></td></tr>
<tr class="separator:ab67ac069d2ebfece00d7ae319389d6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fee298b13394be6481aaa2270e0fed7" id="r_a4fee298b13394be6481aaa2270e0fed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fee298b13394be6481aaa2270e0fed7">shift</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;distance, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;slope, bool right, bool up) const</td></tr>
<tr class="memdesc:a4fee298b13394be6481aaa2270e0fed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and return the curve that results from moving this curve by a given distance and direction.  <br /></td></tr>
<tr class="separator:a4fee298b13394be6481aaa2270e0fed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fafc7198ad4394e07d3c64cbee8a621" id="r_a1fafc7198ad4394e07d3c64cbee8a621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fafc7198ad4394e07d3c64cbee8a621">shiftAgainst</a> (const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;input, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;slope, bool right, bool up, <a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_shift_against_result.html">ShiftAgainstResult</a> &amp;output) const</td></tr>
<tr class="memdesc:a1fafc7198ad4394e07d3c64cbee8a621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance that this curve can be shifted until it 'hits' the input curve.  <br /></td></tr>
<tr class="separator:a1fafc7198ad4394e07d3c64cbee8a621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ebd36b047cb04e60f83097015ec435" id="r_ac8ebd36b047cb04e60f83097015ec435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8ebd36b047cb04e60f83097015ec435">shiftAgainstCircleArc</a> (const CircleArc &amp;<a class="el" href="#af8c6e78e350b81a7239ae7a2436b8885">circleArc</a>, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;slope, bool right, bool up, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;outputDistance, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;outputParam, <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;outputCirclePoint) const</td></tr>
<tr class="memdesc:ac8ebd36b047cb04e60f83097015ec435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance that this curve can be shifted until it 'hits' the input arc.  <br /></td></tr>
<tr class="separator:ac8ebd36b047cb04e60f83097015ec435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87dbe20247d0927666b733b0c125c90" id="r_af87dbe20247d0927666b733b0c125c90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af87dbe20247d0927666b733b0c125c90">sufficientlyCloseAlongCurve</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;curveParam, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;testParam) const</td></tr>
<tr class="memdesc:af87dbe20247d0927666b733b0c125c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two parameters on a curve represent points that have a sufficiently small distance along the curve between them.  <br /></td></tr>
<tr class="separator:af87dbe20247d0927666b733b0c125c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f112b7cd9a321eb60b1181f0f37ee92" id="r_a1f112b7cd9a321eb60b1181f0f37ee92"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f112b7cd9a321eb60b1181f0f37ee92">toString</a> () const</td></tr>
<tr class="memdesc:a1f112b7cd9a321eb60b1181f0f37ee92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string representation of this curve.  <br /></td></tr>
<tr class="separator:a1f112b7cd9a321eb60b1181f0f37ee92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15683b0a0f6b7516eeacdf36e110eda8" id="r_a15683b0a0f6b7516eeacdf36e110eda8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15683b0a0f6b7516eeacdf36e110eda8">valueAt</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;parameter) const</td></tr>
<tr class="memdesc:a15683b0a0f6b7516eeacdf36e110eda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the point on this curve at the specified parameter.  <br /></td></tr>
<tr class="separator:a15683b0a0f6b7516eeacdf36e110eda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af8c6e78e350b81a7239ae7a2436b8885" id="r_af8c6e78e350b81a7239ae7a2436b8885"><td class="memTemplParams" colspan="2">template&lt;std::size_t EDGES&gt; </td></tr>
<tr class="memitem:af8c6e78e350b81a7239ae7a2436b8885"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;(EDGES &gt;1), std::pair&lt; <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a>, EDGES+1 &gt;, <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a>, EDGES &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8c6e78e350b81a7239ae7a2436b8885">circleArc</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;fulcrum, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;radius, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;startCWPositiveVerticalAngle, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;cwAngleSize)</td></tr>
<tr class="memdesc:af8c6e78e350b81a7239ae7a2436b8885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a spline of Bezier curves to approximate a circle arc.  <br /></td></tr>
<tr class="separator:af8c6e78e350b81a7239ae7a2436b8885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3608d952f9998dac37549ddf4087c84" id="r_ab3608d952f9998dac37549ddf4087c84"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3608d952f9998dac37549ddf4087c84">isIntersectionInfinite</a> (const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; std::pair&lt; <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &gt;, 4 &gt; &amp;intersection)</td></tr>
<tr class="memdesc:ab3608d952f9998dac37549ddf4087c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a result returned from <a class="el" href="#a78fe814422473d9cf08b2e80a264772a">BezierCurveQ::pointsOfIntersection</a> represents an infinite intersection.  <br /></td></tr>
<tr class="separator:ab3608d952f9998dac37549ddf4087c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf59c622e3674b3f98ea1562ccc3781" id="r_aecf59c622e3674b3f98ea1562ccc3781"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecf59c622e3674b3f98ea1562ccc3781">longStraightLine</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;start, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;point)</td></tr>
<tr class="memdesc:aecf59c622e3674b3f98ea1562ccc3781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 'long' straight line.  <br /></td></tr>
<tr class="separator:aecf59c622e3674b3f98ea1562ccc3781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90134f740cf63b55c92e2b2a5013c7f0" id="r_a90134f740cf63b55c92e2b2a5013c7f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90134f740cf63b55c92e2b2a5013c7f0">longStraightLine</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;slope, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;point)</td></tr>
<tr class="memdesc:a90134f740cf63b55c92e2b2a5013c7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 'long' straight line.  <br /></td></tr>
<tr class="separator:a90134f740cf63b55c92e2b2a5013c7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac871d3e260fff6f509499142cf6ac4df" id="r_ac871d3e260fff6f509499142cf6ac4df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac871d3e260fff6f509499142cf6ac4df">straightLine</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;s, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;e)</td></tr>
<tr class="memdesc:ac871d3e260fff6f509499142cf6ac4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a straight line.  <br /></td></tr>
<tr class="separator:ac871d3e260fff6f509499142cf6ac4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A quadratic Bezier Curve. </p>
<p>Represents a single quadratic Bezier Curve, meaning that it specifies a start, end, and single control point. The quadratic version of Bezier Curves never intersect themselves, are always convex, and only have at most a single point at a particular slope (with the exception of straight lines).</p>
<p>This implementation supports several functions that are important to a geometry processing system, such as:</p><ul>
<li>Bounding boxes.</li>
<li>Intersection.</li>
<li>Collision detection with other curves, for both rotations and straight line shifts.</li>
<li>Relevant interval calculation for different types of translations.</li>
</ul>
<p>A curve consists of two polynomial functions - one for the X-coordinate and one for the Y-coordinate, derived from the input points and using a single common parameter. These equations are considered defined for parameter ranges [0, 1], with a parameter value of 0 yielding the star point and a value of 1 yielding the end; every other value between these represents a point along the curve. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a80671c0640422512218ad5aa3b8e0ec0" name="a80671c0640422512218ad5aa3b8e0ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80671c0640422512218ad5aa3b8e0ec0">&#9670;&#160;</a></span>BezierCurveQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bezier_geometry::BezierCurveQ::BezierCurveQ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of a curve using the standard parameters. </p>
<p>A quadratic Bezier Curve is created by supplying a start, end and control point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The start point.  </td></tr>
    <tr><td class="paramname">e</td><td>The end point.  </td></tr>
    <tr><td class="paramname">c</td><td>The control point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af8c6e78e350b81a7239ae7a2436b8885" name="af8c6e78e350b81a7239ae7a2436b8885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c6e78e350b81a7239ae7a2436b8885">&#9670;&#160;</a></span>circleArc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t EDGES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;(EDGES &gt;1), std::pair&lt; <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a>, EDGES+1 &gt;, <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a>, EDGES &gt; &gt; &gt;::type bezier_geometry::BezierCurveQ::circleArc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>startCWPositiveVerticalAngle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cwAngleSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a spline of Bezier curves to approximate a circle arc. </p>
<p>Bezier curves cannot model a circle arc, but approximations can be made by using start and end points at equal distances from a fulcrum, and modeling control points to ensure that a set of such curves would be 'continuous' at each endpoint. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A collection of points representing the Bezier curve input points to create the arc approximation. The first entry is the curve endpoints, the second entry are the curve control points. The first entry always has one more entry than the second, since it also encapsulates the end of the last edge. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fulcrum</td><td>The center point for the desired circle arc.  </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the desirec circle arc.  </td></tr>
    <tr><td class="paramname">startCWPositiveVerticalAngle</td><td>The clocwise angle with a vertical line that the circle arc will start at.  </td></tr>
    <tr><td class="paramname">cwAngleSize</td><td>The angle about the fulcrum that the circle arc will extend in the clockwise direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b82a2c5f313fff378b1d295b2354d45" name="a9b82a2c5f313fff378b1d295b2354d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b82a2c5f313fff378b1d295b2354d45">&#9670;&#160;</a></span>curveIntersectionBlocksRotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bezier_geometry::BezierCurveQ::curveIntersectionBlocksRotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>myParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbezier__geometry_1_1_crits_and_values.html">CritsAndValues</a>&lt; 5 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>myDistanceCrits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbezier__geometry_1_1_crits_and_values.html">CritsAndValues</a>&lt; 5 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inputDistanceCrits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>clockwise</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputBlockedCWVerticalAngleStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputBlockedCWVerticalAngleEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>outputAtMyCrit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>outputAtInputCrit</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an intersection will block a rotation. </p>
<p>Generally, if the input curve 'crosses' this curve at the input point there is always a block. A 'cross' refers to when the curves touch, they do not have 'sufficiently close' slopes, and the intersection is also not at either curves' endpoint.</p>
<p>However, if the curves just 'touch' (the reverse of the above 'cross' conditions) at the input point, there may be no block, depending on the input direction. For example, if one curve just touches a straight vertical line at at it's leftmost point, then a clockwise rotation about a point far below either curve would not be blocked by such an intersection. This is helpful when these curves are part of a 2d spline shape and physical bodies are to be simulated.</p>
<p>If the intersection is found to block, other useful data is returned, including the 'blocked angle interval'. These values represent the other directions that would also be blocked by the intersection. Useful for result caching.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___sufficiently_close.html">Close Enough Logic</a> </dd>
<dd>
<a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the input curve blocks a rotation about the input fulcrum in the input direction at the input intersection point. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myParam</td><td>The parameter for this curve where the intersection takes place.  </td></tr>
    <tr><td class="paramname">myDistanceCrits</td><td>The parameters and associated distances between this curve and the fulcrum where the rate of change of this curve's distance changes direction.  </td></tr>
    <tr><td class="paramname">input</td><td>The curve intersecting this curve.  </td></tr>
    <tr><td class="paramname">inputParam</td><td>The parameter for the input curve where the intersection takes place.  </td></tr>
    <tr><td class="paramname">inputDistanceCrits</td><td>The parameters and associated distances between the input curve and the fulcrum where the rate of change of the input curve's distance changes direction.  </td></tr>
    <tr><td class="paramname">fulcrum</td><td>The fulcrum for the rotation.  </td></tr>
    <tr><td class="paramname">clockwise</td><td>The direction of the rotation..  </td></tr>
    <tr><td class="paramname">outputBlockedCWVerticalAngleStart</td><td>Destination for the start of the blocked interval if the intersection is found to be blocking. This is an angle (in degrees) with a vertical line starting at the intersection point and extending 'upwards'. -1 if this intersection is not blocking.  </td></tr>
    <tr><td class="paramname">outputBlockedCWVerticalAngleEnd</td><td>Destination for the end of the blocked interval if the intersection is found to be blocking. This is an angle (in degrees) with a vertical line starting at the intersection point and extending 'upwards'. -1 if this intersection is not blocking.  </td></tr>
    <tr><td class="paramname">outputAtMyCrit</td><td>Destination for the flag indicating that the intersection point is at a distance critical point (change from increasing to decreasing or vice versa) on this curve.  </td></tr>
    <tr><td class="paramname">outputAtInputCrit</td><td>Destination for the flag indicating that the intersection point is at a distance critical point (change from increasing to decreasing or vice versa) on the input curve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ff81ffbea7ad8cc9d2edaaaaa6593c0" name="a7ff81ffbea7ad8cc9d2edaaaaa6593c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff81ffbea7ad8cc9d2edaaaaa6593c0">&#9670;&#160;</a></span>curveIntersectionBlocksShift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bezier_geometry::BezierCurveQ::curveIntersectionBlocksShift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>myParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>up</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>tolerateSmallMagnitudeOverlap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputBlockedCWVerticalAngleStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputBlockedCWVerticalAngleEnd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>outputAtMyCrit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>outputAtInputCrit</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an intersection will block a straight line movement. </p>
<p>Generally, if the input curve 'crosses' this curve at the input point there is always a block. A 'cross' refers to when the curves touch, they do not have 'sufficiently close' slopes, and the intersection is also not at either curves' endpoint.</p>
<p>However, if the curves just 'touch' (the reverse of the above 'cross' conditions) at the input point, there may be no block, depending on the input direction. For example, if one curve just touches a straight vertical line at at it's leftmost point, then a shift anywhere to the right would not be blocked by such an intersection. This is helpful when these curves are part of a 2d spline shape and physical bodies are to be simulated.</p>
<p>If the intersection is found to block, other useful data is returned, including the 'blocked angle interval'. These values represent the other directions that would also be blocked by the intersection. Useful for result caching.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___directional_logic.html">Directional Terminology</a> </dd>
<dd>
<a class="el" href="group___sufficiently_close.html">Close Enough Logic</a> </dd>
<dd>
<a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a> </dd>
<dd>
<a class="el" href="#a9b82a2c5f313fff378b1d295b2354d45" title="Determine if an intersection will block a rotation.">curveIntersectionBlocksRotate</a> </dd>
<dd>
<a class="el" href="classbezier__geometry_1_1_point2_d.html#a326da2071703f3b604846ac42989c016" title="Get a point&#39;s minimum distance from a straight line going through the origin with a given slope.">Point2D::getPerpendicularMagnitude</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the input curve blocks a straight line move in the input direction at the input intersection point. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myParam</td><td>The parameter for this curve where the intersection takes place.  </td></tr>
    <tr><td class="paramname">slope</td><td>The slope along which the movement is to be calculated.  </td></tr>
    <tr><td class="paramname">right</td><td>The direction along the input slope that the shift is to be calculated.  </td></tr>
    <tr><td class="paramname">up</td><td>The direction along the input slope, only used if the slope is very large.  </td></tr>
    <tr><td class="paramname">inputParam</td><td>The parameter for the input curve where the intersection takes place. It is assumed that the input curve's value at this parameter matches tha of this curve at this curve's parameter.  </td></tr>
    <tr><td class="paramname">input</td><td>The other curve that is intersecting this curve.  </td></tr>
    <tr><td class="paramname">tolerateSmallMagnitudeOverlap</td><td>Flag for considering a 'sufficiently small' overlap in these curves' 'perpendicular magnitude' for the input slope to not block. Generally this should always be true except for when this method is recycled as a part of calculating a rotation block, where tolerances must be tighter.  </td></tr>
    <tr><td class="paramname">outputBlockedCWVerticalAngleStart</td><td>Destination for the start of the blocked interval if the intersection is found to be blocking. This is an angle (in degrees) with a vertical line starting at the intersection point and extending 'upwards'. -1 if this intersection is not blocking.  </td></tr>
    <tr><td class="paramname">outputBlockedCWVerticalAngleEnd</td><td>Destination for the end of the blocked interval if the intersection is found to be blocking. This is an angle (in degrees) with a vertical line starting at the intersection point and extending 'upwards'. -1 if this intersection is not blocking.  </td></tr>
    <tr><td class="paramname">outputAtMyCrit</td><td>Destination for the flag indicating that the intersection point is at a 'perpendicular magnitude' critical point (change from increasing to decreasing or vice versa) on this curve.  </td></tr>
    <tr><td class="paramname">outputAtInputCrit</td><td>Destination for the flag indicating that the intersection point is at a 'perpendicular magnitude' critical point (change from increasing to decreasing or vice versa) on the input curve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19754b3703256ecf261fe2407c520e95" name="a19754b3703256ecf261fe2407c520e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19754b3703256ecf261fe2407c520e95">&#9670;&#160;</a></span>getConcavityIndicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> bezier_geometry::BezierCurveQ::getConcavityIndicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a point that indicates the direction of this curve's concavity. </p>
<p>If a curve is not a straight line, it curves in a direction at a given parameter. This function will return a point that results from shifting the curve's value at the input parameter by a slope perpendicular to this curve's slope at the parameter by a constant distance in the direction of its concavity.</p>
<p>For example, if a curve were to make a vertically symmetrical 'U' shape, then its concavity indicator at parameter 0.5 would be the central point in the curve shifted straight up.</p>
<dl class="section return"><dt>Returns</dt><dd>A point indicating the direction that this curve is bending in. If this curve is a straight line, the value at the parameter is simply returned with no shift. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>The parameter to evaluate this curve's concavity. Must be in the range [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac27c5f027b6caffcbd7cd41fc9b1beae" name="ac27c5f027b6caffcbd7cd41fc9b1beae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27c5f027b6caffcbd7cd41fc9b1beae">&#9670;&#160;</a></span>getConcavitySlope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::BezierCurveQ::getConcavitySlope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a numeric value indicating how 'curved' this curve is at a given point. </p>
<p>This is a ratio that represents the degree of this curve's concavity. The ratio is not against this curve's parameter, instead, it is relative to the coordinate space that the curve exists in. This means that any curve with a higher value from this function is more concave, or 'curved' at the given parameter than any other curve with a lower value.</p>
<p>The result is always positive and not affected by the direction of a curve's concavity. Therefore, the lowest possible return value for this function would be to call it on a straight line.</p>
<dl class="section return"><dt>Returns</dt><dd>A numeric value indicating how concave/curved this curve is at the input parameter. Always positive, always higher for more real curvature, consistent across curves. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>The parameter to evaluate this curve's concavity. Must be in the range [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a490ccf7dc1b60fcca2d96ca5b6b53edc" name="a490ccf7dc1b60fcca2d96ca5b6b53edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490ccf7dc1b60fcca2d96ca5b6b53edc">&#9670;&#160;</a></span>getControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp; bezier_geometry::BezierCurveQ::getControl </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the single control point for this curve. </p>
<dl class="section return"><dt>Returns</dt><dd>This curve's Bezier control point. </dd></dl>

</div>
</div>
<a id="a9fdbf2ac178f1682afb54c3245ab976d" name="a9fdbf2ac178f1682afb54c3245ab976d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdbf2ac178f1682afb54c3245ab976d">&#9670;&#160;</a></span>getCurveDistanceParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>, 4 &gt; bezier_geometry::BezierCurveQ::getCurveDistanceParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>distance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>startParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>endParam</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameters for this curve for a given distance from a point. </p>
<p>Given a fulcrum point and a desired distance, calculate the parameters for this curve that result in points at the desired distance.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of parameters, each in the range [startParam, endParam], for this curve that yield points at the desired distance. Possibly empty. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fulcrum</td><td>The point from which the desired distance is calculated.  </td></tr>
    <tr><td class="paramname">distance</td><td>The desired distance.  </td></tr>
    <tr><td class="paramname">startParam</td><td>Calculate the desired distance over a subset of this curve, starting at this value. Must be in the range [0, 1].  </td></tr>
    <tr><td class="paramname">endParam</td><td>Calculate the desired distance over a subset of this curve, ending at this value. Must be in the range [startParam, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a921886bfda9ca6cd010d0c1121a2e6b3" name="a921886bfda9ca6cd010d0c1121a2e6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921886bfda9ca6cd010d0c1121a2e6b3">&#9670;&#160;</a></span>getCWAngleIntervals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bezier_geometry::BezierCurveQ::getCWAngleIntervals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_c_w_angle_interval.html">CWAngleInterval</a>, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputFirstSet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_c_w_angle_interval.html">CWAngleInterval</a>, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outputSecondSet</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a set of intervals for this curve for its angle ranges about a fulcrum. </p>
<p>Relative to a fulcrum, this curve will 'move', meaning that as its parameter increases it generates points that are clockwise of previous points, counterclockwise of previous points, or neither (in the case of straight lines pointing at the fulcrum).</p>
<p>This function gets these intervals, meaning that for every interval found the parameter ranges and the angle values are added to the result. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fulcrum</td><td>The fulcrum that the angles about are to be calculated.  </td></tr>
    <tr><td class="paramname">outputFirstSet</td><td>Destination for the list of results.  </td></tr>
    <tr><td class="paramname">outputSecondSet</td><td>Destination for the second list of results. This is only populated if the fulcrum is a point on this curve and in that case, this represents the angle intervals on the opposite side of the fulcrum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad09ffde9fe0af6ca9abbde5592ba7963" name="ad09ffde9fe0af6ca9abbde5592ba7963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09ffde9fe0af6ca9abbde5592ba7963">&#9670;&#160;</a></span>getDirectionIndicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> bezier_geometry::BezierCurveQ::getDirectionIndicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a point that is on a tangential straight line from this curve at a parameter. </p>
<p>At any valid parameter, a curve evaluates to a single point. Also, at this point the curve has a slope and may be considered to have a direction, which refers to the direction along its current slope it will move if the parameter were to increase.</p>
<p>This returns a point that is this curve's value at the input parameter, shifted by a constant distance in the curve's direction.</p>
<dl class="section return"><dt>Returns</dt><dd>A point representing this curve's slope and direction. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>The parameter for this curve to evaluate the direction at; must be in the range [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0267507b857ef41a8dca7851a5570123" name="a0267507b857ef41a8dca7851a5570123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0267507b857ef41a8dca7851a5570123">&#9670;&#160;</a></span>getDistanceCritsAndValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbezier__geometry_1_1_crits_and_values.html">CritsAndValues</a>&lt; 5 &gt; bezier_geometry::BezierCurveQ::getDistanceCritsAndValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get this curve's distance intervals from a point. </p>
<p>For a given point, moving along a curve (increasing its parameter) will either result in points closer to or farther from the point. This calculates every point where a curve stops getting closer and starts getting farther from the point and vice versa. The result also includes this curve's end points and their respective distances.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of parameters for this curve (all in the interval [0, 1]) and their respective distances from the input point where the 'direction of distance' changes relative to this curve's parameter. A quadratic Bezier curve may have no more than 3 parameters for which its 'distance direction' changes; this fact, paired with the inclusion of the endpoints totals no more than 5 possible critical points. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The point that distances on this curve are measured from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fe322f0f81d52cbbdf667aef21b8628" name="a8fe322f0f81d52cbbdf667aef21b8628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe322f0f81d52cbbdf667aef21b8628">&#9670;&#160;</a></span>getMaxXExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::BezierCurveQ::getMaxXExtent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the highest X-coordinate that any point on this curve occupies. </p>
<dl class="section return"><dt>Returns</dt><dd>The highest X-coordinate that this curve reaches. </dd></dl>

</div>
</div>
<a id="a788f2e192f2f5da2c0a782b768e24159" name="a788f2e192f2f5da2c0a782b768e24159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788f2e192f2f5da2c0a782b768e24159">&#9670;&#160;</a></span>getMaxXPara()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::BezierCurveQ::getMaxXPara </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameter for the highest X-coordinate that any point on this curve occupies. </p>
<dl class="section return"><dt>Returns</dt><dd>The parameter for the highest X-coordinate that this curve reaches. Always in the range [0, 1]. </dd></dl>

</div>
</div>
<a id="ae1bef3e008ed0b013d28c015d7ece808" name="ae1bef3e008ed0b013d28c015d7ece808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bef3e008ed0b013d28c015d7ece808">&#9670;&#160;</a></span>getMaxYExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::BezierCurveQ::getMaxYExtent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the highest Y-coordinate that any point on this curve occupies. </p>
<dl class="section return"><dt>Returns</dt><dd>The highest Y-coordinate that this curve reaches. </dd></dl>

</div>
</div>
<a id="aa56d416f16e0aa1138c5c52492c4544d" name="aa56d416f16e0aa1138c5c52492c4544d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56d416f16e0aa1138c5c52492c4544d">&#9670;&#160;</a></span>getMaxYPara()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::BezierCurveQ::getMaxYPara </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameter for the highest Y-coordinate that any point on this curve occupies. </p>
<dl class="section return"><dt>Returns</dt><dd>The parameter for the highest Y-coordinate that this curve reaches. Always in the range [0, 1]. </dd></dl>

</div>
</div>
<a id="ac11b916bf16435496899009211c5da0b" name="ac11b916bf16435496899009211c5da0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11b916bf16435496899009211c5da0b">&#9670;&#160;</a></span>getMinXExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::BezierCurveQ::getMinXExtent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lowest X-coordinate that any point on this curve occupies. </p>
<dl class="section return"><dt>Returns</dt><dd>The lowest X-coordinate that this curve reaches. </dd></dl>

</div>
</div>
<a id="ac918cc69a549367fd93421cd19f46abf" name="ac918cc69a549367fd93421cd19f46abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac918cc69a549367fd93421cd19f46abf">&#9670;&#160;</a></span>getMinXPara()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::BezierCurveQ::getMinXPara </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameter for the lowest X-coordinate that any point on this curve occupies. </p>
<dl class="section return"><dt>Returns</dt><dd>The parameter for the lowest X-coordinate that this curve reaches. Always in the range [0, 1]. </dd></dl>

</div>
</div>
<a id="a9385195b6a3214b90d86569b54f8d388" name="a9385195b6a3214b90d86569b54f8d388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9385195b6a3214b90d86569b54f8d388">&#9670;&#160;</a></span>getMinYExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::BezierCurveQ::getMinYExtent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lowest Y-coordinate that any point on this curve occupies. </p>
<dl class="section return"><dt>Returns</dt><dd>The lowest Y-coordinate that this curve reaches. </dd></dl>

</div>
</div>
<a id="a9310081f4bd9ec2a0c615ddb5107da07" name="a9310081f4bd9ec2a0c615ddb5107da07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9310081f4bd9ec2a0c615ddb5107da07">&#9670;&#160;</a></span>getMinYPara()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::BezierCurveQ::getMinYPara </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameter for the lowest Y-coordinate that any point on this curve occupies. </p>
<dl class="section return"><dt>Returns</dt><dd>The parameter for the lowest Y-coordinate that this curve reaches. Always in the range [0, 1]. </dd></dl>

</div>
</div>
<a id="a09d7ed205c84779a2acae08561087ad7" name="a09d7ed205c84779a2acae08561087ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d7ed205c84779a2acae08561087ad7">&#9670;&#160;</a></span>getPerpendicularMagnitudeCritsAndValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbezier__geometry_1_1_crits_and_values.html">CritsAndValues</a>&lt; 3 &gt; bezier_geometry::BezierCurveQ::getPerpendicularMagnitudeCritsAndValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slope</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ranges of 'perpendicular magnitudes' that this curve exists in for a given slope. </p>
<p>For a given slope, a Quadratic Bezier curve's 'perpendicular magnitude' changes direction (goes from increasing to decreasing or vice versa) relative to the curve's parameter at most once. The magnitude of this curve's endpoints is also calculated, meaning that there can be at most 3 points of interest.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_point2_d.html#a326da2071703f3b604846ac42989c016" title="Get a point&#39;s minimum distance from a straight line going through the origin with a given slope.">Point2D::getPerpendicularMagnitude</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The list of Bezier parameters for endpoints and changes in direction for this curve's 'perpendicular magnitude' for the input slope, along with the associated 'perpendicular magnitude' values for each parameter. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slope</td><td>The slope to evaluate perpendicular magnitudes for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3608d952f9998dac37549ddf4087c84" name="ab3608d952f9998dac37549ddf4087c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3608d952f9998dac37549ddf4087c84">&#9670;&#160;</a></span>isIntersectionInfinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bezier_geometry::BezierCurveQ::isIntersectionInfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; std::pair&lt; <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &gt;, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>intersection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a result returned from <a class="el" href="#a78fe814422473d9cf08b2e80a264772a">BezierCurveQ::pointsOfIntersection</a> represents an infinite intersection. </p>
<p>An infinite intersection results from determining the intersection between 2 curves that overlap and therefore intersect at an interval of parameters instead of a set of points.</p>
<p>An infinite intersection's first entry is a pair of NaN values, but its second and third entries are the start and end parameters for the overlapping interval between the two curves.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the input intersection represents an infinite intersection. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intersection</td><td>The intersection to be tested for an infinite intersection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecf59c622e3674b3f98ea1562ccc3781" name="aecf59c622e3674b3f98ea1562ccc3781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf59c622e3674b3f98ea1562ccc3781">&#9670;&#160;</a></span>longStraightLine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> bezier_geometry::BezierCurveQ::longStraightLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 'long' straight line. </p>
<p>The resulting curve represents a straight line that is 25000 units long..</p>
<dl class="section return"><dt>Returns</dt><dd>A straight line, starting at a given point and extending in a direction that causes it to cross the other given point. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The start point of the desired line.  </td></tr>
    <tr><td class="paramname">point</td><td>Another point that lies along the line, not necessarily an endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90134f740cf63b55c92e2b2a5013c7f0" name="a90134f740cf63b55c92e2b2a5013c7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90134f740cf63b55c92e2b2a5013c7f0">&#9670;&#160;</a></span>longStraightLine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> bezier_geometry::BezierCurveQ::longStraightLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 'long' straight line. </p>
<p>The resulting curve represents a straight line that is 50000 units long with the given slope and the given point in the middle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___directional_logic.html">Directional Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A straight line. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slope</td><td>The desired slope of the resulting line.  </td></tr>
    <tr><td class="paramname">point</td><td>The mid-point of the resulting straight line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9fd868c0fff56f654656df15486e4f7" name="aa9fd868c0fff56f654656df15486e4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fd868c0fff56f654656df15486e4f7">&#9670;&#160;</a></span>maxDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::BezierCurveQ::maxDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the point on this curve that is farthest from the input point. </p>
<p>This is the same as calling BezierCurveQ::maxDistance(input, 0, 1).</p>
<dl class="section return"><dt>Returns</dt><dd>The parameter value for this curve that yields a point farther from the input point than any other on this curve. Always in the range [0, 1]. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The point from which the farthest distance is to be calculated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a45682c2c56345d2c804e06ffe1c5fe" name="a0a45682c2c56345d2c804e06ffe1c5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a45682c2c56345d2c804e06ffe1c5fe">&#9670;&#160;</a></span>maxDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::BezierCurveQ::maxDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>minParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>maxParam</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the point on this curve that is farthest from the input point within a parameter range. </p>
<p>The farthest point on the section of this curve specified by the input parameters is calculated.</p>
<dl class="section return"><dt>Returns</dt><dd>The parameter value for this curve that yields a point farther from the input point than any other on this curve within the specified parameter range. Always in the range [minParam, maxParam]. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The point from which the farthest distance is to be calculated.  </td></tr>
    <tr><td class="paramname">minParam</td><td>The parameter indicating the start of the segment of this curve to perform the calculation on. Must be in the range [0, 1]  </td></tr>
    <tr><td class="paramname">maxParam</td><td>The parameter indicating the end of the segment of this curve to perform the calculation on. Must be in the range [minParam, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44b496ee406174cd2ff2be869495bdea" name="a44b496ee406174cd2ff2be869495bdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b496ee406174cd2ff2be869495bdea">&#9670;&#160;</a></span>minDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::BezierCurveQ::minDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the point on this curve that is closest to the input point. </p>
<p>This is the same as calling BezierCurveQ::minDistance(input, 0, 1).</p>
<dl class="section return"><dt>Returns</dt><dd>The parameter value for this curve that yields a point closer to the input point than any other on this curve. Always in the range [0, 1]. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The point to which the closest distance is to be calculated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25c86f9ae101dd0d4f67942db1453e2c" name="a25c86f9ae101dd0d4f67942db1453e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c86f9ae101dd0d4f67942db1453e2c">&#9670;&#160;</a></span>minDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::BezierCurveQ::minDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>minParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>maxParam</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the point on this curve that is closest to the input point within a parameter range. </p>
<p>The closest point on the section of this curve specified by the input parameters is calculated.</p>
<dl class="section return"><dt>Returns</dt><dd>The parameter value for this curve that yields a point closer to the input point than any other on this curve within the specified parameter range. Always in the range [minParam, maxParam]. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The point to which the closest distance is to be calculated.  </td></tr>
    <tr><td class="paramname">minParam</td><td>The parameter indicating the start of the segment of this curve to perform the calculation on. Must be in the range [0, 1]  </td></tr>
    <tr><td class="paramname">maxParam</td><td>The parameter indicating the end of the segment of this curve to perform the calculation on. Must be in the range [minParam, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4b849e49e2ba1fe096f33294006e766" name="ad4b849e49e2ba1fe096f33294006e766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b849e49e2ba1fe096f33294006e766">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bezier_geometry::BezierCurveQ::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if this curve is sufficiently close to the input curve to be considered equivalent. </p>
<p>Equivalence is determined by comparing each curve's start, end, and control points using the conditions for point equivalence. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_point2_d.html#aeb75666c44fbeedd4650ad37c04796b4" title="Determines if this and the input point are approximately the same.">Point2D::operator==</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if this curve and the input curve are equal. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The curve that is to be compared against this curve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9bd12a9a615e02c6f81b8b5cdc87f77" name="ab9bd12a9a615e02c6f81b8b5cdc87f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bd12a9a615e02c6f81b8b5cdc87f77">&#9670;&#160;</a></span>paramForPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::BezierCurveQ::paramForPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Bezier parameter for this curve that will result in a given point. </p>
<p>This is effectively the reverse of <a class="el" href="#a15683b0a0f6b7516eeacdf36e110eda8">BezierCurveQ::valueAt</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The parameter for this curve that results in the given point. In the range [0, 1] if the input point is found along this curve, -1 if it is not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The point that a parameter for this curve is to be found for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a46ae9d4dd7686de1999f0d2eb56da0" name="a8a46ae9d4dd7686de1999f0d2eb56da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a46ae9d4dd7686de1999f0d2eb56da0">&#9670;&#160;</a></span>pointShiftAgainstParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>, 2 &gt; bezier_geometry::BezierCurveQ::pointShiftAgainstParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skipIntersections</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameters for this curve that are along a slope from a point. </p>
<p>Given a point and slope, calculate the parameters for this curve that will yield points that form the input slope with the input point. In other words. If the input point were to be shifted along the input slope, find the parameters for this curve where it could intersect. There may be no intersections.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___directional_logic.html">Directional Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A list of parameters for this curve all in the range [0, 1] where the input point can match along the input slope. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The point for which a shift is being calculated.  </td></tr>
    <tr><td class="paramname">slope</td><td>The slope of the shift.  </td></tr>
    <tr><td class="paramname">skipIntersections</td><td>The input point may lie along this curve. If this is the case, setting this flag to true will not include parameters for the input point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78fe814422473d9cf08b2e80a264772a" name="a78fe814422473d9cf08b2e80a264772a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fe814422473d9cf08b2e80a264772a">&#9670;&#160;</a></span>pointsOfIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; std::pair&lt; <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>, <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &gt;, 4 &gt; bezier_geometry::BezierCurveQ::pointsOfIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the points of intersection for this and another curve. </p>
<p>Two quadratic Bezier curves cannot intersect at more than 4 points.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of parameter pairs (each numeric value in the range [0, 1]). The first entry in each pair is a parameter to this curve, the second is a parameter to the input curve; each pair representing a point at which these curves intersect. There is a special case for curves that infinitely intersect. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab3608d952f9998dac37549ddf4087c84" title="Determine if a result returned from BezierCurveQ::pointsOfIntersection represents an infinite interse...">isIntersectionInfinite</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The other curve to test for intersection with this curve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a289c5b1b42462906b631d58946a696b6" name="a289c5b1b42462906b631d58946a696b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289c5b1b42462906b631d58946a696b6">&#9670;&#160;</a></span>rateOfChangeAtParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::BezierCurveQ::rateOfChangeAtParam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get this curve's slope at a parameter. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___directional_logic.html">Directional Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This curve's slope at the given parameter. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>The curve parameter to evaluate the slope at. Must be in the range [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2139a4bde1e4dfce10f5b6d295093aa6" name="a2139a4bde1e4dfce10f5b6d295093aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2139a4bde1e4dfce10f5b6d295093aa6">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> bezier_geometry::BezierCurveQ::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>angle</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and return the curve that results from rotating this curve. </p>
<p>The new curve is derived by simply constructing a new curve with this curve's start, end and control points rotated by the input parameters. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_point2_d.html#a1a6b296d1d74c34cc9167488d341706e" title="Get the result of rotating this point about another point.">Point2D::rotate</a> </dd>
<dd>
<a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The curve resulting from the input rotation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fulcrum</td><td>The fulcrum about which the rotation is to be calculated.  </td></tr>
    <tr><td class="paramname">angle</td><td>The angle (in degrees) to be rotated; an angle that is a multiple of 360 (including 0) results in a curve equivalent to this one. Keeping with the behaviour of a rotation matrix, negative angles are 'clockwise' and positive angles are 'counterclockwise'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a551b65207eb94582d96cf3a6d02f8e2c" name="a551b65207eb94582d96cf3a6d02f8e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551b65207eb94582d96cf3a6d02f8e2c">&#9670;&#160;</a></span>rotateAgainst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bezier_geometry::BezierCurveQ::rotateAgainst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clockwise</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_rotate_against_result.html">BezierCurveQ::RotateAgainstResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the angle that this curve can be rotated until it 'hits' the input curve. </p>
<p>Given a fulcrum and rotation direction, calculate how much of an angle this curve can be rotated until it is 'blocked' by the input curve. This method also calculates other potentially useful values, such as the resulting intersection parameters for both curves and the other directions that would also be blocked if such a rotation were performed and subsequent moves were attempted.</p>
<p>A 'block' is not necessarily a place where this curve would touch/intersect after a rotation. Any such touch must sufficiently overlap the direction of rotation to ensure that a 'graze' would not cause a block, such as one curve simply moving tangentially to another.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a> </dd>
<dd>
<a class="el" href="group___sufficiently_close.html">Close Enough Logic</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The curve that a rotation against will be checked for 'blocks'.  </td></tr>
    <tr><td class="paramname">fulcrum</td><td>The fulcrum of the rotation.  </td></tr>
    <tr><td class="paramname">clockwise</td><td>The direction of the rotation.  </td></tr>
    <tr><td class="paramname">output</td><td>The destination for the calculated results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab67ac069d2ebfece00d7ae319389d6e7" name="ab67ac069d2ebfece00d7ae319389d6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67ac069d2ebfece00d7ae319389d6e7">&#9670;&#160;</a></span>rotateAgainstCircleArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bezier_geometry::BezierCurveQ::rotateAgainstCircleArc </td>
          <td>(</td>
          <td class="paramtype">const CircleArc &amp;</td>          <td class="paramname"><span class="paramname"><em>circleArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clockwise</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputAngle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputCirclePoint</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the angle that this curve can be rotated until it 'hits' the input arc. </p>
<p>Given a fulcrum and rotation direction, calculate how much of an angle this curve can be rotated until it is 'blocked' by the input arc.</p>
<p>A 'block' is not necessarily a place where this curve would touch/intersect after a rotation. Any such touch must sufficiently overlap the direction of rotation to ensure that a 'graze' would not cause a block, such as one curve simply moving tangentially to another.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a> </dd>
<dd>
<a class="el" href="group___sufficiently_close.html">Close Enough Logic</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circleArc</td><td>The arc that angles and blocking points are to be calculated against.  </td></tr>
    <tr><td class="paramname">fulcrum</td><td>The fulcrum of the rotation.  </td></tr>
    <tr><td class="paramname">clockwise</td><td>The direction of the rotation.  </td></tr>
    <tr><td class="paramname">outputAngle</td><td>Destination for the calculated angle that this curve could rotate until it is blocked by the input arc. -1 if this rotation is not blocked.  </td></tr>
    <tr><td class="paramname">outputParam</td><td>Destination for the parameter for this curve that represents the blocking point. In the range [0, 1] if there is a block; -1 if this rotation is not blocked.  </td></tr>
    <tr><td class="paramname">outputCirclePoint</td><td>Destination for point on the input circle arc that blocks. This is not assigned if there is no block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fee298b13394be6481aaa2270e0fed7" name="a4fee298b13394be6481aaa2270e0fed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fee298b13394be6481aaa2270e0fed7">&#9670;&#160;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> bezier_geometry::BezierCurveQ::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>distance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>up</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and return the curve that results from moving this curve by a given distance and direction. </p>
<p>The new curve is derived by simply constructing a new curve with this curve's start, end and control points shifted by the input parameters. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_point2_d.html#afd4102c24a4ac60946e2ca03567d8d9b" title="Get the result of moving this point by a given distance and direction.">Point2D::shift</a> </dd>
<dd>
<a class="el" href="group___directional_logic.html">Directional Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The curve resulting from the input shift. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance</td><td>The straight-line distance to be moved.  </td></tr>
    <tr><td class="paramname">slope</td><td>The slope along which the movement is to be calculated.  </td></tr>
    <tr><td class="paramname">right</td><td>The direction along the input slope.  </td></tr>
    <tr><td class="paramname">up</td><td>The direction along the input slope, only used if the slope is very large. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fafc7198ad4394e07d3c64cbee8a621" name="a1fafc7198ad4394e07d3c64cbee8a621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fafc7198ad4394e07d3c64cbee8a621">&#9670;&#160;</a></span>shiftAgainst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bezier_geometry::BezierCurveQ::shiftAgainst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>up</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbezier__geometry_1_1_bezier_curve_q_1_1_shift_against_result.html">BezierCurveQ::ShiftAgainstResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance that this curve can be shifted until it 'hits' the input curve. </p>
<p>Given a shift direction, calculate how far this curve can be moved in a straight line until it is 'blocked' by the input curve. This method also calculates other potentially useful values, such as the resulting intersection parameters for both curves and the other directions that would also be blocked if such a shift were performed and subsequent moves were attempted.</p>
<p>A 'block' is not necessarily a place where this curve would touch/intersect after a rotation. Any such touch must sufficiently overlap the direction of rotation to ensure that a 'graze' would not cause a block, such as one curve simply moving tangentially to another.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___directional_logic.html">Directional Terminology</a> </dd>
<dd>
<a class="el" href="group___sufficiently_close.html">Close Enough Logic</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The curve that a shift against will be checked for 'blocks'.  </td></tr>
    <tr><td class="paramname">slope</td><td>The slope along which the movement is to be calculated.  </td></tr>
    <tr><td class="paramname">right</td><td>The direction along the input slope.  </td></tr>
    <tr><td class="paramname">up</td><td>The direction along the input slope, only used if the slope is very large.  </td></tr>
    <tr><td class="paramname">output</td><td>The destination for the calculated results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8ebd36b047cb04e60f83097015ec435" name="ac8ebd36b047cb04e60f83097015ec435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ebd36b047cb04e60f83097015ec435">&#9670;&#160;</a></span>shiftAgainstCircleArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bezier_geometry::BezierCurveQ::shiftAgainstCircleArc </td>
          <td>(</td>
          <td class="paramtype">const CircleArc &amp;</td>          <td class="paramname"><span class="paramname"><em>circleArc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>up</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputCirclePoint</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance that this curve can be shifted until it 'hits' the input arc. </p>
<p>Given a shift direction, calculate how far this curve can be moved in a straight line until it is 'blocked' by the input arc.</p>
<p>A 'block' is not necessarily a place where this curve would touch/intersect after a rotation. Any such touch must sufficiently overlap the direction of rotation to ensure that a 'graze' would not cause a block, such as one curve simply moving tangentially to another.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___directional_logic.html">Directional Terminology</a> </dd>
<dd>
<a class="el" href="group___sufficiently_close.html">Close Enough Logic</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">circleArc</td><td>The arc that distances and blocking points are to be calculated against.  </td></tr>
    <tr><td class="paramname">slope</td><td>The slope along which the movement is to be calculated.  </td></tr>
    <tr><td class="paramname">right</td><td>The direction along the input slope that the shift is to be calculated.  </td></tr>
    <tr><td class="paramname">up</td><td>The direction along the input slope, only used if the slope is very large.  </td></tr>
    <tr><td class="paramname">outputDistance</td><td>Destination for the calculated distance until this curve is blocked. -1 if this rotation is not blocked.  </td></tr>
    <tr><td class="paramname">outputParam</td><td>Destination for this curve's parameter where it would be blocked by the input arc. In the range [0, 1] if there is a block; -1 if there is no block.  </td></tr>
    <tr><td class="paramname">outputCirclePoint</td><td>Destination for the point on the input circle arc where the block will occur. This is not assigned if there is no block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac871d3e260fff6f509499142cf6ac4df" name="ac871d3e260fff6f509499142cf6ac4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac871d3e260fff6f509499142cf6ac4df">&#9670;&#160;</a></span>straightLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> bezier_geometry::BezierCurveQ::straightLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a straight line. </p>
<dl class="section return"><dt>Returns</dt><dd>A straight line between the two input points. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The start point for the desired curve.  </td></tr>
    <tr><td class="paramname">e</td><td>The end point for the desired curve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af87dbe20247d0927666b733b0c125c90" name="af87dbe20247d0927666b733b0c125c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87dbe20247d0927666b733b0c125c90">&#9670;&#160;</a></span>sufficientlyCloseAlongCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bezier_geometry::BezierCurveQ::sufficientlyCloseAlongCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>curveParam</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>testParam</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two parameters on a curve represent points that have a sufficiently small distance along the curve between them. </p>
<p>Sufficiently close parameters are not necessarily parameter values that are sufficiently close, but a function of the difference in the parameters and the 'speed' at which a curve's calculated points change relative to the parameters. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___sufficiently_close.html">Close Enough Logic</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the 2 parameters represent points with a sufficiently small 'arc distance' along the curve between them. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curveParam</td><td>The first parameter for this curve.  </td></tr>
    <tr><td class="paramname">testParam</td><td>The second parameter for this curve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f112b7cd9a321eb60b1181f0f37ee92" name="a1f112b7cd9a321eb60b1181f0f37ee92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f112b7cd9a321eb60b1181f0f37ee92">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string bezier_geometry::BezierCurveQ::toString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string representation of this curve. </p>
<dl class="section return"><dt>Returns</dt><dd>A string consisting of START-CONTROL-END. </dd></dl>

</div>
</div>
<a id="a15683b0a0f6b7516eeacdf36e110eda8" name="a15683b0a0f6b7516eeacdf36e110eda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15683b0a0f6b7516eeacdf36e110eda8">&#9670;&#160;</a></span>valueAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> bezier_geometry::BezierCurveQ::valueAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parameter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the point on this curve at the specified parameter. </p>
<p>Bezier curves are continuous, so there is a point for every valid parameter.</p>
<dl class="section return"><dt>Returns</dt><dd>The point on this curve for the given parameter. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter</td><td>The parameter for this curve to evaluate the point at; must be in the range [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_bezier_curve_q_8hpp_source.html">BezierCurveQ.hpp</a></li>
<li><b>BezierCurveQ.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
