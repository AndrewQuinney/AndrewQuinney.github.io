<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bezier Geometry: bezier_geometry::StaticVector&lt; T, MAX_SIZE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bezier Geometry
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bezier_geometry</b></li><li class="navelem"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbezier__geometry_1_1_static_vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">bezier_geometry::StaticVector&lt; T, MAX_SIZE &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A simple expandable list that avoids dynamic allocation.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_static_vector_8hpp_source.html">StaticVector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a57cf206b6fba16f5b4288ff026e52d8b" id="r_a57cf206b6fba16f5b4288ff026e52d8b"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57cf206b6fba16f5b4288ff026e52d8b">const_iterator</a></td></tr>
<tr class="separator:a57cf206b6fba16f5b4288ff026e52d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67528457fcd992c21cc0ddf3d736e4b" id="r_ac67528457fcd992c21cc0ddf3d736e4b"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a></td></tr>
<tr class="separator:ac67528457fcd992c21cc0ddf3d736e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae143906f579a752b63be275a73b9154f" id="r_ae143906f579a752b63be275a73b9154f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae143906f579a752b63be275a73b9154f">back</a> ()</td></tr>
<tr class="memdesc:ae143906f579a752b63be275a73b9154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the last element in this list.  <br /></td></tr>
<tr class="separator:ae143906f579a752b63be275a73b9154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6e81034aed366e5ebeb9ad74fbfce5" id="r_a5a6e81034aed366e5ebeb9ad74fbfce5"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a6e81034aed366e5ebeb9ad74fbfce5">back</a> () const</td></tr>
<tr class="memdesc:a5a6e81034aed366e5ebeb9ad74fbfce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the last element in this list.  <br /></td></tr>
<tr class="separator:a5a6e81034aed366e5ebeb9ad74fbfce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1115d2540daf3601a20615c0ef3e86dd" id="r_a1115d2540daf3601a20615c0ef3e86dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a57cf206b6fba16f5b4288ff026e52d8b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1115d2540daf3601a20615c0ef3e86dd">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a1115d2540daf3601a20615c0ef3e86dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator to the beginning of this list.  <br /></td></tr>
<tr class="separator:a1115d2540daf3601a20615c0ef3e86dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420c46ff77376725175f20a02ebcf84a" id="r_a420c46ff77376725175f20a02ebcf84a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a420c46ff77376725175f20a02ebcf84a">begin</a> () noexcept</td></tr>
<tr class="memdesc:a420c46ff77376725175f20a02ebcf84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator to the beginning of this list.  <br /></td></tr>
<tr class="separator:a420c46ff77376725175f20a02ebcf84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000978d2a53e5cd3ef889adf0214b79a" id="r_a000978d2a53e5cd3ef889adf0214b79a"><td class="memItemLeft" align="right" valign="top"><a id="a000978d2a53e5cd3ef889adf0214b79a" name="a000978d2a53e5cd3ef889adf0214b79a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a000978d2a53e5cd3ef889adf0214b79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and destroys every entry in this list. <br /></td></tr>
<tr class="separator:a000978d2a53e5cd3ef889adf0214b79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad349af179208df41678ac2851733366f" id="r_ad349af179208df41678ac2851733366f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad349af179208df41678ac2851733366f">empty</a> () const</td></tr>
<tr class="memdesc:ad349af179208df41678ac2851733366f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this list is empty.  <br /></td></tr>
<tr class="separator:ad349af179208df41678ac2851733366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03749b3e20d059d33695c7bfc2e3d51" id="r_ad03749b3e20d059d33695c7bfc2e3d51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a57cf206b6fba16f5b4288ff026e52d8b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad03749b3e20d059d33695c7bfc2e3d51">end</a> () const noexcept</td></tr>
<tr class="memdesc:ad03749b3e20d059d33695c7bfc2e3d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator pointing just past the end of this list.  <br /></td></tr>
<tr class="separator:ad03749b3e20d059d33695c7bfc2e3d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359b3323ae2f11f030e6404470359776" id="r_a359b3323ae2f11f030e6404470359776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a359b3323ae2f11f030e6404470359776">end</a> () noexcept</td></tr>
<tr class="memdesc:a359b3323ae2f11f030e6404470359776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator pointing just past the end of this list.  <br /></td></tr>
<tr class="separator:a359b3323ae2f11f030e6404470359776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e425f4e3667f0e77c263cb2ec7d37d" id="r_ac2e425f4e3667f0e77c263cb2ec7d37d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2e425f4e3667f0e77c263cb2ec7d37d">erase</a> (<a class="el" href="#a57cf206b6fba16f5b4288ff026e52d8b">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ac2e425f4e3667f0e77c263cb2ec7d37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element at a given position.  <br /></td></tr>
<tr class="separator:ac2e425f4e3667f0e77c263cb2ec7d37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bf1bf9cfec234875f04d2bc6be2ee8" id="r_a82bf1bf9cfec234875f04d2bc6be2ee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82bf1bf9cfec234875f04d2bc6be2ee8">erase</a> (<a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a> first, <a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a> last)</td></tr>
<tr class="memdesc:a82bf1bf9cfec234875f04d2bc6be2ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a block of entries from this list.  <br /></td></tr>
<tr class="separator:a82bf1bf9cfec234875f04d2bc6be2ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6732440b7d330d70dbc939c07a642b39" id="r_a6732440b7d330d70dbc939c07a642b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6732440b7d330d70dbc939c07a642b39">erase</a> (<a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a> pos)</td></tr>
<tr class="memdesc:a6732440b7d330d70dbc939c07a642b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the element at a given position.  <br /></td></tr>
<tr class="separator:a6732440b7d330d70dbc939c07a642b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2db61cb7aaa288d4c83ac4b92b7053" id="r_a9d2db61cb7aaa288d4c83ac4b92b7053"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d2db61cb7aaa288d4c83ac4b92b7053">front</a> ()</td></tr>
<tr class="memdesc:a9d2db61cb7aaa288d4c83ac4b92b7053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first element in this list.  <br /></td></tr>
<tr class="separator:a9d2db61cb7aaa288d4c83ac4b92b7053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb37d27938b365ac29077a83ec24382e" id="r_afb37d27938b365ac29077a83ec24382e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb37d27938b365ac29077a83ec24382e">front</a> () const</td></tr>
<tr class="memdesc:afb37d27938b365ac29077a83ec24382e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first element in this list.  <br /></td></tr>
<tr class="separator:afb37d27938b365ac29077a83ec24382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3f2bca0b9ec37067d8f44d190da05c" id="r_a6e3f2bca0b9ec37067d8f44d190da05c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e3f2bca0b9ec37067d8f44d190da05c">operator!=</a> (const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;input)</td></tr>
<tr class="memdesc:a6e3f2bca0b9ec37067d8f44d190da05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests this list for non-equivalence to another list.  <br /></td></tr>
<tr class="separator:a6e3f2bca0b9ec37067d8f44d190da05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4e6674f069677003c766e0af15ef96" id="r_a5a4e6674f069677003c766e0af15ef96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a4e6674f069677003c766e0af15ef96">operator=</a> (const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;input)</td></tr>
<tr class="memdesc:a5a4e6674f069677003c766e0af15ef96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assignment operator.  <br /></td></tr>
<tr class="separator:a5a4e6674f069677003c766e0af15ef96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31248c14259bfc71f89b2fd4c52258e2" id="r_a31248c14259bfc71f89b2fd4c52258e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31248c14259bfc71f89b2fd4c52258e2">operator=</a> (<a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;&amp;input)</td></tr>
<tr class="memdesc:a31248c14259bfc71f89b2fd4c52258e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assignment operator.  <br /></td></tr>
<tr class="separator:a31248c14259bfc71f89b2fd4c52258e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301547816a6b708e9e3e3b7fa3a5f79b" id="r_a301547816a6b708e9e3e3b7fa3a5f79b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a301547816a6b708e9e3e3b7fa3a5f79b">operator==</a> (const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;input) const</td></tr>
<tr class="memdesc:a301547816a6b708e9e3e3b7fa3a5f79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests this list for equivalence to another list.  <br /></td></tr>
<tr class="separator:a301547816a6b708e9e3e3b7fa3a5f79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c0b4d556c80fe7ffb611aeaf874383" id="r_ae5c0b4d556c80fe7ffb611aeaf874383"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5c0b4d556c80fe7ffb611aeaf874383">operator[]</a> (const std::size_t &amp;index)</td></tr>
<tr class="memdesc:ae5c0b4d556c80fe7ffb611aeaf874383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element at an index.  <br /></td></tr>
<tr class="separator:ae5c0b4d556c80fe7ffb611aeaf874383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403c8321199110d00c1fb945c8b6e710" id="r_a403c8321199110d00c1fb945c8b6e710"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a403c8321199110d00c1fb945c8b6e710">operator[]</a> (const std::size_t &amp;index) const</td></tr>
<tr class="memdesc:a403c8321199110d00c1fb945c8b6e710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element at an index.  <br /></td></tr>
<tr class="separator:a403c8321199110d00c1fb945c8b6e710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88bf5df96e000ea39af68cf580c1edf" id="r_ab88bf5df96e000ea39af68cf580c1edf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab88bf5df96e000ea39af68cf580c1edf">push_back</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ab88bf5df96e000ea39af68cf580c1edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of this list.  <br /></td></tr>
<tr class="separator:ab88bf5df96e000ea39af68cf580c1edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa6daa65aa8e4205508d5b635c6dc69" id="r_a4fa6daa65aa8e4205508d5b635c6dc69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fa6daa65aa8e4205508d5b635c6dc69">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a4fa6daa65aa8e4205508d5b635c6dc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a value to the end of this list.  <br /></td></tr>
<tr class="separator:a4fa6daa65aa8e4205508d5b635c6dc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1c7e8e16c8b027fa03884edb0fcba8" id="r_aca1c7e8e16c8b027fa03884edb0fcba8"><td class="memItemLeft" align="right" valign="top">const std::size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca1c7e8e16c8b027fa03884edb0fcba8">size</a> () const</td></tr>
<tr class="memdesc:aca1c7e8e16c8b027fa03884edb0fcba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items in this list.  <br /></td></tr>
<tr class="separator:aca1c7e8e16c8b027fa03884edb0fcba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39342355f478fe82c20a811a4bb1a838" id="r_a39342355f478fe82c20a811a4bb1a838"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39342355f478fe82c20a811a4bb1a838">StaticVector</a> ()</td></tr>
<tr class="memdesc:a39342355f478fe82c20a811a4bb1a838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new, empty list.  <br /></td></tr>
<tr class="separator:a39342355f478fe82c20a811a4bb1a838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af851e35842eaad51f58971db8952c4f5" id="r_af851e35842eaad51f58971db8952c4f5"><td class="memTemplParams" colspan="2">template&lt;std::size_t INPUT_MAX_SIZE&gt; </td></tr>
<tr class="memitem:af851e35842eaad51f58971db8952c4f5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af851e35842eaad51f58971db8952c4f5">StaticVector</a> (const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, INPUT_MAX_SIZE &gt; &amp;input)</td></tr>
<tr class="memdesc:af851e35842eaad51f58971db8952c4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:af851e35842eaad51f58971db8952c4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aace133258b9cc8dd13e281c509e423" id="r_a5aace133258b9cc8dd13e281c509e423"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aace133258b9cc8dd13e281c509e423">StaticVector</a> (const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;input)</td></tr>
<tr class="memdesc:a5aace133258b9cc8dd13e281c509e423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a5aace133258b9cc8dd13e281c509e423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a28e9e62d1f304f0c588811a54f74c" id="r_a31a28e9e62d1f304f0c588811a54f74c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31a28e9e62d1f304f0c588811a54f74c">StaticVector</a> (const std::initializer_list&lt; T &gt; &amp;input)</td></tr>
<tr class="memdesc:a31a28e9e62d1f304f0c588811a54f74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list constructor.  <br /></td></tr>
<tr class="separator:a31a28e9e62d1f304f0c588811a54f74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab223feb5dda0b997e074f765dec8b3b0" id="r_ab223feb5dda0b997e074f765dec8b3b0"><td class="memTemplParams" colspan="2">template&lt;std::size_t INPUT_MAX_SIZE&gt; </td></tr>
<tr class="memitem:ab223feb5dda0b997e074f765dec8b3b0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab223feb5dda0b997e074f765dec8b3b0">StaticVector</a> (<a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, INPUT_MAX_SIZE &gt; &amp;&amp;input)</td></tr>
<tr class="memdesc:ab223feb5dda0b997e074f765dec8b3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:ab223feb5dda0b997e074f765dec8b3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f20297ea38d16249bbdbedab9d1a059" id="r_a4f20297ea38d16249bbdbedab9d1a059"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f20297ea38d16249bbdbedab9d1a059">StaticVector</a> (<a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;&amp;input)</td></tr>
<tr class="memdesc:a4f20297ea38d16249bbdbedab9d1a059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a4f20297ea38d16249bbdbedab9d1a059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c4f3abdba766276734426fe288ff1" id="r_ab75c4f3abdba766276734426fe288ff1"><td class="memItemLeft" align="right" valign="top"><a id="ab75c4f3abdba766276734426fe288ff1" name="ab75c4f3abdba766276734426fe288ff1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~StaticVector</b> ()</td></tr>
<tr class="memdesc:ab75c4f3abdba766276734426fe288ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor - clears this list. <br /></td></tr>
<tr class="separator:ab75c4f3abdba766276734426fe288ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, std::size_t MAX_SIZE&gt;<br />
class bezier_geometry::StaticVector&lt; T, MAX_SIZE &gt;</div><p>A simple expandable list that avoids dynamic allocation. </p>
<p>This is designed to operate as a drop-in replacement for std::vector, the difference is that a maximum size must be specified and it uses memory equivalent to a std::array of the same type and size.</p>
<p>Since the module makes use of functions of limited degree, reductions, solutions, intervals always have a guaranteed maximum size (eg. a function of degree 3 cannot have more than 3 real roots). This property, coupled with this class, enables the avoidance of dynamic (heap-based) memory allocation for most operations, resulting in greatly improved performance.</p>
<p>There are other STL allocators that use a stack buffer, such as Chromium's 'StackAllocator', which would enable this type of behaviour from a std::vector, but that allocator has additional logic to overflow onto the heap if it runs out of stack space. This means that there is always some additional checking compared to this class, which is unnecessary overhead when it is guaranteed to never overflow. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a57cf206b6fba16f5b4288ff026e52d8b" name="a57cf206b6fba16f5b4288ff026e52d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cf206b6fba16f5b4288ff026e52d8b">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of a constant iterator for this list. </p>

</div>
</div>
<a id="ac67528457fcd992c21cc0ddf3d736e4b" name="ac67528457fcd992c21cc0ddf3d736e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67528457fcd992c21cc0ddf3d736e4b">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of an iterator for this list. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a39342355f478fe82c20a811a4bb1a838" name="a39342355f478fe82c20a811a4bb1a838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39342355f478fe82c20a811a4bb1a838">&#9670;&#160;</a></span>StaticVector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::StaticVector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new, empty list. </p>
<p>No instances of the contained type are constructed, though this instance will occupy the stack space of such types in the specified count. </p>

</div>
</div>
<a id="a31a28e9e62d1f304f0c588811a54f74c" name="a31a28e9e62d1f304f0c588811a54f74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a28e9e62d1f304f0c588811a54f74c">&#9670;&#160;</a></span>StaticVector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::StaticVector </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list constructor. </p>
<p>Attempts to copy every entry in the input list into this list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The list to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af851e35842eaad51f58971db8952c4f5" name="af851e35842eaad51f58971db8952c4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af851e35842eaad51f58971db8952c4f5">&#9670;&#160;</a></span>StaticVector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<div class="memtemplate">
template&lt;std::size_t INPUT_MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::StaticVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, INPUT_MAX_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Attempts to copy every entry in the input list into this list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The list to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5aace133258b9cc8dd13e281c509e423" name="a5aace133258b9cc8dd13e281c509e423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aace133258b9cc8dd13e281c509e423">&#9670;&#160;</a></span>StaticVector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::StaticVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Attempts to copy every entry in the input list into this list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The list to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab223feb5dda0b997e074f765dec8b3b0" name="ab223feb5dda0b997e074f765dec8b3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab223feb5dda0b997e074f765dec8b3b0">&#9670;&#160;</a></span>StaticVector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<div class="memtemplate">
template&lt;std::size_t INPUT_MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::StaticVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, INPUT_MAX_SIZE &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Attempts to move every entry in the input list into this list then clears the input list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The list to be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f20297ea38d16249bbdbedab9d1a059" name="a4f20297ea38d16249bbdbedab9d1a059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f20297ea38d16249bbdbedab9d1a059">&#9670;&#160;</a></span>StaticVector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::StaticVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Attempts to move every entry in the input list into this list then clears the input list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The list to be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae143906f579a752b63be275a73b9154f" name="ae143906f579a752b63be275a73b9154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae143906f579a752b63be275a73b9154f">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the last element in this list. </p>
<p>Behaviour is undefined if this list is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>The last value in this list. </dd></dl>

</div>
</div>
<a id="a5a6e81034aed366e5ebeb9ad74fbfce5" name="a5a6e81034aed366e5ebeb9ad74fbfce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6e81034aed366e5ebeb9ad74fbfce5">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the last element in this list. </p>
<p>Behaviour is undefined if this list is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>The last value in this list. </dd></dl>

</div>
</div>
<a id="a1115d2540daf3601a20615c0ef3e86dd" name="a1115d2540daf3601a20615c0ef3e86dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1115d2540daf3601a20615c0ef3e86dd">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a57cf206b6fba16f5b4288ff026e52d8b">const_iterator</a> <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an iterator to the beginning of this list. </p>
<p>Behaviour is undefined if this list is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of this list. </dd></dl>

</div>
</div>
<a id="a420c46ff77376725175f20a02ebcf84a" name="a420c46ff77376725175f20a02ebcf84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420c46ff77376725175f20a02ebcf84a">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a> <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an iterator to the beginning of this list. </p>
<p>Behaviour is undefined if this list is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of this list. </dd></dl>

</div>
</div>
<a id="ad349af179208df41678ac2851733366f" name="ad349af179208df41678ac2851733366f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad349af179208df41678ac2851733366f">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this list is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this list is empty. </dd></dl>

</div>
</div>
<a id="ad03749b3e20d059d33695c7bfc2e3d51" name="ad03749b3e20d059d33695c7bfc2e3d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03749b3e20d059d33695c7bfc2e3d51">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a57cf206b6fba16f5b4288ff026e52d8b">const_iterator</a> <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an iterator pointing just past the end of this list. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing past the end of this list. </dd></dl>

</div>
</div>
<a id="a359b3323ae2f11f030e6404470359776" name="a359b3323ae2f11f030e6404470359776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359b3323ae2f11f030e6404470359776">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a> <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an iterator pointing just past the end of this list. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing past the end of this list. </dd></dl>

</div>
</div>
<a id="ac2e425f4e3667f0e77c263cb2ec7d37d" name="ac2e425f4e3667f0e77c263cb2ec7d37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e425f4e3667f0e77c263cb2ec7d37d">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a> <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a57cf206b6fba16f5b4288ff026e52d8b">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the element at a given position. </p>
<p>This is equivalent to calling erase(pos, std::next(pos)). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a82bf1bf9cfec234875f04d2bc6be2ee8" title="Erase a block of entries from this list.">StaticVector::erase</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing at the element past the removed element, possibly past the end of this list. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82bf1bf9cfec234875f04d2bc6be2ee8" name="a82bf1bf9cfec234875f04d2bc6be2ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bf1bf9cfec234875f04d2bc6be2ee8">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a> <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a block of entries from this list. </p>
<p>The entries in a given range are destroyed and removed from this list.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the erased block, possibly equivalent to <a class="el" href="#a359b3323ae2f11f030e6404470359776">StaticVector::end</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator pointing to the first element to be removed.  </td></tr>
    <tr><td class="paramname">last</td><td>An iterator pointing past the last element to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6732440b7d330d70dbc939c07a642b39" name="a6732440b7d330d70dbc939c07a642b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6732440b7d330d70dbc939c07a642b39">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a> <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac67528457fcd992c21cc0ddf3d736e4b">iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases the element at a given position. </p>
<p>This is equivalent to calling erase(pos, std::next(pos)). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a82bf1bf9cfec234875f04d2bc6be2ee8" title="Erase a block of entries from this list.">StaticVector::erase</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing at the element past the removed element, possibly past the end of this list. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the element to be erased. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d2db61cb7aaa288d4c83ac4b92b7053" name="a9d2db61cb7aaa288d4c83ac4b92b7053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2db61cb7aaa288d4c83ac4b92b7053">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the first element in this list. </p>
<p>Behaviour is undefined if this list is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>The first value in this list. </dd></dl>

</div>
</div>
<a id="afb37d27938b365ac29077a83ec24382e" name="afb37d27938b365ac29077a83ec24382e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb37d27938b365ac29077a83ec24382e">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the first element in this list. </p>
<p>Behaviour is undefined if this list is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>The first value in this list. </dd></dl>

</div>
</div>
<a id="a6e3f2bca0b9ec37067d8f44d190da05c" name="a6e3f2bca0b9ec37067d8f44d190da05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3f2bca0b9ec37067d8f44d190da05c">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests this list for non-equivalence to another list. </p>
<p>This is just the inverse of <a class="el" href="#a301547816a6b708e9e3e3b7fa3a5f79b">StaticVector::operator==</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this list is not equal to the input list. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The list to be tested against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a4e6674f069677003c766e0af15ef96" name="a5a4e6674f069677003c766e0af15ef96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4e6674f069677003c766e0af15ef96">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp; <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assignment operator. </p>
<p>Clears this list and copies every element from the input list to this list.</p>
<dl class="section return"><dt>Returns</dt><dd>This list. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The list to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31248c14259bfc71f89b2fd4c52258e2" name="a31248c14259bfc71f89b2fd4c52258e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31248c14259bfc71f89b2fd4c52258e2">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp; <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assignment operator. </p>
<p>Clears this list, moves every element from the input list to this list, and clears the input list.</p>
<dl class="section return"><dt>Returns</dt><dd>This list. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The list to be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a301547816a6b708e9e3e3b7fa3a5f79b" name="a301547816a6b708e9e3e3b7fa3a5f79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301547816a6b708e9e3e3b7fa3a5f79b">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_static_vector.html">StaticVector</a>&lt; T, MAX_SIZE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests this list for equivalence to another list. </p>
<p>Two lists are equal if they are the same size and every element at the same index in each list is equivalent.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this and the input list are equal. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The list to be tested for equality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5c0b4d556c80fe7ffb611aeaf874383" name="ae5c0b4d556c80fe7ffb611aeaf874383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c0b4d556c80fe7ffb611aeaf874383">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element at an index. </p>
<p>Undefined behaviour if the index is outside the range [0, size).</p>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified index. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element to return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a403c8321199110d00c1fb945c8b6e710" name="a403c8321199110d00c1fb945c8b6e710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403c8321199110d00c1fb945c8b6e710">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element at an index. </p>
<p>Undefined behaviour if the index is outside the range [0, size).</p>
<dl class="section return"><dt>Returns</dt><dd>The element at the specified index. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element to return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab88bf5df96e000ea39af68cf580c1edf" name="ab88bf5df96e000ea39af68cf580c1edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88bf5df96e000ea39af68cf580c1edf">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of this list. </p>
<p>The input value is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to copy into this list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fa6daa65aa8e4205508d5b635c6dc69" name="a4fa6daa65aa8e4205508d5b635c6dc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa6daa65aa8e4205508d5b635c6dc69">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a value to the end of this list. </p>
<p>The input value is moved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to move into this list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca1c7e8e16c8b027fa03884edb0fcba8" name="aca1c7e8e16c8b027fa03884edb0fcba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1c7e8e16c8b027fa03884edb0fcba8">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t MAX_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::size_t &amp; <a class="el" href="classbezier__geometry_1_1_static_vector.html">bezier_geometry::StaticVector</a>&lt; T, MAX_SIZE &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items in this list. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of items in this list. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_static_vector_8hpp_source.html">StaticVector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
