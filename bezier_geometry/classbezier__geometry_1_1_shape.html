<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bezier Geometry: bezier_geometry::Shape Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bezier Geometry
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bezier_geometry</b></li><li class="navelem"><a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classbezier__geometry_1_1_shape-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">bezier_geometry::Shape Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A two dimensional shape.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_shape_8hpp_source.html">Shape.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbezier__geometry_1_1_shape_1_1_edge_section.html">EdgeSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subset of a shape's edges.  <a href="structbezier__geometry_1_1_shape_1_1_edge_section.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbezier__geometry_1_1_shape_1_1_rotate_against_result.html">RotateAgainstResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a 'rotate against' operation.  <a href="structbezier__geometry_1_1_shape_1_1_rotate_against_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbezier__geometry_1_1_shape_1_1_shape_overlap.html">ShapeOverlap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shape that represents an overlap between 2 other shapes.  <a href="classbezier__geometry_1_1_shape_1_1_shape_overlap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbezier__geometry_1_1_shape_1_1_shift_against_result.html">ShiftAgainstResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a 'shift against' operation.  <a href="structbezier__geometry_1_1_shape_1_1_shift_against_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48df60bf33f826749f94546ff834c171" id="r_a48df60bf33f826749f94546ff834c171"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48df60bf33f826749f94546ff834c171">getEdges</a> () const</td></tr>
<tr class="memdesc:a48df60bf33f826749f94546ff834c171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges for this shape.  <br /></td></tr>
<tr class="separator:a48df60bf33f826749f94546ff834c171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ef318c1c999a9cfed4529104d92184" id="r_ac7ef318c1c999a9cfed4529104d92184"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7ef318c1c999a9cfed4529104d92184">getMaxX</a> () const</td></tr>
<tr class="memdesc:ac7ef318c1c999a9cfed4529104d92184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest X-coordinate this shape occupies.  <br /></td></tr>
<tr class="separator:ac7ef318c1c999a9cfed4529104d92184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8b7204a43c8856ce54ad18b4a8582e" id="r_afb8b7204a43c8856ce54ad18b4a8582e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb8b7204a43c8856ce54ad18b4a8582e">getMaxY</a> () const</td></tr>
<tr class="memdesc:afb8b7204a43c8856ce54ad18b4a8582e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest Y-coordinate this shape occupies.  <br /></td></tr>
<tr class="separator:afb8b7204a43c8856ce54ad18b4a8582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57fa5498abf3c5cd46f4b712d47b328" id="r_ad57fa5498abf3c5cd46f4b712d47b328"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad57fa5498abf3c5cd46f4b712d47b328">getMinX</a> () const</td></tr>
<tr class="memdesc:ad57fa5498abf3c5cd46f4b712d47b328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lowest X-coordinate this shape occupies.  <br /></td></tr>
<tr class="separator:ad57fa5498abf3c5cd46f4b712d47b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea3fe9b26b2df26aa47d4ce59c8c9ea" id="r_a7ea3fe9b26b2df26aa47d4ce59c8c9ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ea3fe9b26b2df26aa47d4ce59c8c9ea">getMinY</a> () const</td></tr>
<tr class="memdesc:a7ea3fe9b26b2df26aa47d4ce59c8c9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lowest Y-coordinate this shape occupies.  <br /></td></tr>
<tr class="separator:a7ea3fe9b26b2df26aa47d4ce59c8c9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bd12dfcf065c01a2fd810d9b555840" id="r_ad3bd12dfcf065c01a2fd810d9b555840"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbezier__geometry_1_1_shape_1_1_shape_overlap.html">ShapeOverlap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3bd12dfcf065c01a2fd810d9b555840">getOverlap</a> (const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;input) const</td></tr>
<tr class="memdesc:ad3bd12dfcf065c01a2fd810d9b555840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the overlap between this and another shape.  <br /></td></tr>
<tr class="separator:ad3bd12dfcf065c01a2fd810d9b555840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2253b480db288f9268180876182aa3a" id="r_ae2253b480db288f9268180876182aa3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2253b480db288f9268180876182aa3a">pointInPolygon</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;testPoint) const</td></tr>
<tr class="memdesc:ae2253b480db288f9268180876182aa3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if a given point lies within this shape.  <br /></td></tr>
<tr class="separator:ae2253b480db288f9268180876182aa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac82440508aaa98ec6dd116399a9a0b" id="r_a6ac82440508aaa98ec6dd116399a9a0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ac82440508aaa98ec6dd116399a9a0b">rotate</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;fulcrum, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;angle) const</td></tr>
<tr class="memdesc:a6ac82440508aaa98ec6dd116399a9a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a version of this shape resulting from a rotation.  <br /></td></tr>
<tr class="separator:a6ac82440508aaa98ec6dd116399a9a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc2c9b9831c7d309a2c8090e8ec4444" id="r_a6bc2c9b9831c7d309a2c8090e8ec4444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bc2c9b9831c7d309a2c8090e8ec4444">rotateAgainst</a> (const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;input, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;fulcrum, bool clockwise, <a class="el" href="structbezier__geometry_1_1_shape_1_1_rotate_against_result.html">RotateAgainstResult</a> &amp;output) const</td></tr>
<tr class="memdesc:a6bc2c9b9831c7d309a2c8090e8ec4444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the angle that this shape can be rotated until it 'hits' the input shape.  <br /></td></tr>
<tr class="separator:a6bc2c9b9831c7d309a2c8090e8ec4444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f49fbe2008de22b410872a5bcbe526f" id="r_a9f49fbe2008de22b410872a5bcbe526f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f49fbe2008de22b410872a5bcbe526f">rotateAgainstAfterRotating</a> (const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;inputBeforeMove, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;inputRotationAngle, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;inputRotationFulcrum, bool inputRotationClockwise, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;myRotationFulcrum, bool myRotationClockwise) const</td></tr>
<tr class="memdesc:a9f49fbe2008de22b410872a5bcbe526f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate being 'pushed out of the way' by another shape's rotation.  <br /></td></tr>
<tr class="separator:a9f49fbe2008de22b410872a5bcbe526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b04b58bb5a060c98356ebb8eb2da68" id="r_a51b04b58bb5a060c98356ebb8eb2da68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51b04b58bb5a060c98356ebb8eb2da68">rotateAgainstAfterShifting</a> (const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;inputBeforeMove, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;inputShiftDistance, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;inputShiftSlope, bool inputShiftRight, bool inputShiftUp, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;myRotationFulcrum, bool myRotationClockwise) const</td></tr>
<tr class="memdesc:a51b04b58bb5a060c98356ebb8eb2da68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate being 'pushed out of the way' by another shape's shift.  <br /></td></tr>
<tr class="separator:a51b04b58bb5a060c98356ebb8eb2da68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9798715fe45bd0f5a0a96bf2e4154ad0" id="r_a9798715fe45bd0f5a0a96bf2e4154ad0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9798715fe45bd0f5a0a96bf2e4154ad0">Shape</a> (const std::vector&lt; <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &gt; &amp;verticies, const std::vector&lt; <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &gt; &amp;controlPoints)</td></tr>
<tr class="memdesc:a9798715fe45bd0f5a0a96bf2e4154ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shape as a set of Bezier curves.  <br /></td></tr>
<tr class="separator:a9798715fe45bd0f5a0a96bf2e4154ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4291c69a38b7eafba18a9a66b02ddb26" id="r_a4291c69a38b7eafba18a9a66b02ddb26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4291c69a38b7eafba18a9a66b02ddb26">shift</a> (const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;distance, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;slope, bool right, bool up) const</td></tr>
<tr class="memdesc:a4291c69a38b7eafba18a9a66b02ddb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a version of this shape resulting from a straight line shift.  <br /></td></tr>
<tr class="separator:a4291c69a38b7eafba18a9a66b02ddb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5839650a00c67b9f8b35ce0fc2631cc7" id="r_a5839650a00c67b9f8b35ce0fc2631cc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5839650a00c67b9f8b35ce0fc2631cc7">shiftAgainst</a> (const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;input, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;slope, bool right, bool up, <a class="el" href="structbezier__geometry_1_1_shape_1_1_shift_against_result.html">ShiftAgainstResult</a> &amp;output) const</td></tr>
<tr class="memdesc:a5839650a00c67b9f8b35ce0fc2631cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the distance that this shape can be shifted until it 'hits' the input shape.  <br /></td></tr>
<tr class="separator:a5839650a00c67b9f8b35ce0fc2631cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34039c8e4527f093c5f9fcb130dc821" id="r_ad34039c8e4527f093c5f9fcb130dc821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad34039c8e4527f093c5f9fcb130dc821">shiftAgainstAfterRotating</a> (const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;inputBeforeMove, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;inputRotationAngle, const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;inputRotationFulcrum, bool inputRotationClockwise, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;myShiftSlope, bool myShiftRight, bool myShiftUp) const</td></tr>
<tr class="memdesc:ad34039c8e4527f093c5f9fcb130dc821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate being 'pushed out of the way' by another shape's rotation.  <br /></td></tr>
<tr class="separator:ad34039c8e4527f093c5f9fcb130dc821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dd163770d993a80c75d32d6a65c21e" id="r_a20dd163770d993a80c75d32d6a65c21e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20dd163770d993a80c75d32d6a65c21e">shiftAgainstAfterShifting</a> (const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;inputBeforeMove, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;inputShiftDistance, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;inputShiftSlope, bool inputShiftRight, bool inputShiftUp, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;myShiftSlope, bool myShiftRight, bool myShiftUp) const</td></tr>
<tr class="memdesc:a20dd163770d993a80c75d32d6a65c21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate being 'pushed out of the way' by another shape's shift.  <br /></td></tr>
<tr class="separator:a20dd163770d993a80c75d32d6a65c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb79c784f40959917bcceae803f88205" id="r_acb79c784f40959917bcceae803f88205"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb79c784f40959917bcceae803f88205">toString</a> () const</td></tr>
<tr class="memdesc:acb79c784f40959917bcceae803f88205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string representation of this shape.  <br /></td></tr>
<tr class="separator:acb79c784f40959917bcceae803f88205"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3e2b0adbd32deea3089f9cc662029fee" id="r_a3e2b0adbd32deea3089f9cc662029fee"><td class="memTemplParams" colspan="2">template&lt;std::size_t EDGES&gt; </td></tr>
<tr class="memitem:a3e2b0adbd32deea3089f9cc662029fee"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e2b0adbd32deea3089f9cc662029fee">approximateCircle</a> (const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;centre, const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;radius)</td></tr>
<tr class="memdesc:a3e2b0adbd32deea3089f9cc662029fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shape that approximates a circle.  <br /></td></tr>
<tr class="separator:a3e2b0adbd32deea3089f9cc662029fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A two dimensional shape. </p>
<p>A shape consists of at least 2 Bezier curves that form a closed loop, where the start of the first curve equals the end of the last curve. This is the only valid point of intersection between a shape's edges. Much like the curves that make up its edges, a shape can perform move calculation and collision detection, but with a spline of curves instead of individual curves. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9798715fe45bd0f5a0a96bf2e4154ad0" name="a9798715fe45bd0f5a0a96bf2e4154ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9798715fe45bd0f5a0a96bf2e4154ad0">&#9670;&#160;</a></span>Shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bezier_geometry::Shape::Shape </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>verticies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>controlPoints</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shape as a set of Bezier curves. </p>
<p>The input points are interpreted to form a spline of curves in a closed loop. If the curves that result from this intersect one another anywhere except for the start of the first and the end of the last, it is an invalid use case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verticies</td><td>The set of curve endpoints. Each entry is considered both the end of a curve and the start of the next curve. There must be at least 2 entries in this set.  </td></tr>
    <tr><td class="paramname">controlPoints</td><td>The set of curve control points. This must be the same size as the verticies set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3e2b0adbd32deea3089f9cc662029fee" name="a3e2b0adbd32deea3089f9cc662029fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2b0adbd32deea3089f9cc662029fee">&#9670;&#160;</a></span>approximateCircle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t EDGES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> bezier_geometry::Shape::approximateCircle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>centre</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shape that approximates a circle. </p>
<p>Increasing the EDGES value will create a closer approximation of a circle.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html#af8c6e78e350b81a7239ae7a2436b8885" title="Get a spline of Bezier curves to approximate a circle arc.">BezierCurveQ::circleArc</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A new shape with the specified number of edges that models a circle as closely as a possible. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">centre</td><td>The centre of the desired circle.  </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the desired circle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48df60bf33f826749f94546ff834c171" name="a48df60bf33f826749f94546ff834c171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48df60bf33f826749f94546ff834c171">&#9670;&#160;</a></span>getEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html">BezierCurveQ</a> &gt; &amp; bezier_geometry::Shape::getEdges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges for this shape. </p>
<dl class="section return"><dt>Returns</dt><dd>The set of edges that this shape consists of. </dd></dl>

</div>
</div>
<a id="ac7ef318c1c999a9cfed4529104d92184" name="ac7ef318c1c999a9cfed4529104d92184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ef318c1c999a9cfed4529104d92184">&#9670;&#160;</a></span>getMaxX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::Shape::getMaxX </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the highest X-coordinate this shape occupies. </p>
<p>In a coordinate system where higher X-coordinates are 'right', this would be the right side of the shape's bounding box.</p>
<dl class="section return"><dt>Returns</dt><dd>The highest X-coordinate this shape occupies. </dd></dl>

</div>
</div>
<a id="afb8b7204a43c8856ce54ad18b4a8582e" name="afb8b7204a43c8856ce54ad18b4a8582e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8b7204a43c8856ce54ad18b4a8582e">&#9670;&#160;</a></span>getMaxY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::Shape::getMaxY </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the highest Y-coordinate this shape occupies. </p>
<p>In a coordinate system where higher Y-coordinates are 'up', this would be the top of the shape's bounding box.</p>
<dl class="section return"><dt>Returns</dt><dd>The highest Y-coordinate this shape occupies. </dd></dl>

</div>
</div>
<a id="ad57fa5498abf3c5cd46f4b712d47b328" name="ad57fa5498abf3c5cd46f4b712d47b328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57fa5498abf3c5cd46f4b712d47b328">&#9670;&#160;</a></span>getMinX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::Shape::getMinX </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lowest X-coordinate this shape occupies. </p>
<p>In a coordinate system where higher X-coordinates are 'right', this would be the left side of the shape's bounding box.</p>
<dl class="section return"><dt>Returns</dt><dd>The lowest X-coordinate this shape occupies. </dd></dl>

</div>
</div>
<a id="a7ea3fe9b26b2df26aa47d4ce59c8c9ea" name="a7ea3fe9b26b2df26aa47d4ce59c8c9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea3fe9b26b2df26aa47d4ce59c8c9ea">&#9670;&#160;</a></span>getMinY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp; bezier_geometry::Shape::getMinY </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lowest Y-coordinate this shape occupies. </p>
<p>In a coordinate system where higher Y-coordinates are 'up', this would be the bottom of the shape's bounding box.</p>
<dl class="section return"><dt>Returns</dt><dd>The lowest Y-coordinate this shape occupies. </dd></dl>

</div>
</div>
<a id="ad3bd12dfcf065c01a2fd810d9b555840" name="ad3bd12dfcf065c01a2fd810d9b555840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bd12dfcf065c01a2fd810d9b555840">&#9670;&#160;</a></span>getOverlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classbezier__geometry_1_1_shape_1_1_shape_overlap.html">Shape::ShapeOverlap</a> &gt; bezier_geometry::Shape::getOverlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the overlap between this and another shape. </p>
<p>2 shapes that overlap can have their overlap represented as a set of other shapes, which represent the area common to both shapes. Each entry in such a set would consist of a contiguous set of edges from one shape and a contiguous set of edges from the input shape, each representing the edges from one curve inside the other.</p>
<dl class="section return"><dt>Returns</dt><dd>A set of overlaps, each representing an area that both shapes occupy. Empty if there is no overlap. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The shape to be checked for overlaps with this shape. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2253b480db288f9268180876182aa3a" name="ae2253b480db288f9268180876182aa3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2253b480db288f9268180876182aa3a">&#9670;&#160;</a></span>pointInPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bezier_geometry::Shape::pointInPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>testPoint</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if a given point lies within this shape. </p>
<p>A point is considered to lie within this shape, on the edge of this shape, or outside of this shape.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the input point lies within this shape; 0 if the input point lies on the edge of this shape; -1 if the input point is outside this shape. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">testPoint</td><td>The point to check if it is within this shape. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ac82440508aaa98ec6dd116399a9a0b" name="a6ac82440508aaa98ec6dd116399a9a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac82440508aaa98ec6dd116399a9a0b">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> bezier_geometry::Shape::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>angle</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a version of this shape resulting from a rotation. </p>
<p>Creates a rotated version of this shape by simply rotating all of the edges' end and control points. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_point2_d.html#a1a6b296d1d74c34cc9167488d341706e" title="Get the result of rotating this point about another point.">Point2D::rotate</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Another shape that results from rotating this shape. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fulcrum</td><td>The point about which the rotation is to be performed.  </td></tr>
    <tr><td class="paramname">angle</td><td>The angle (in degrees) to be rotated; an angle that is a multiple of 360 (including 0) results in a point equivalent to this point. Keeping with the behaviour of a rotation matrix, negative angles are 'clockwise' and positive angles are 'counterclockwise'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bc2c9b9831c7d309a2c8090e8ec4444" name="a6bc2c9b9831c7d309a2c8090e8ec4444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc2c9b9831c7d309a2c8090e8ec4444">&#9670;&#160;</a></span>rotateAgainst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bezier_geometry::Shape::rotateAgainst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clockwise</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbezier__geometry_1_1_shape_1_1_rotate_against_result.html">RotateAgainstResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the angle that this shape can be rotated until it 'hits' the input shape. </p>
<p>Given a fulcrum and rotation direction, calculate how much of an angle this curve can be rotated until it is 'blocked' by the input curve. This is effectively an aggregate of the same method for individual curves, with some optimization around relevant intervals for a given direction. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html#a551b65207eb94582d96cf3a6d02f8e2c" title="Calculate the angle that this curve can be rotated until it &#39;hits&#39; the input curve.">BezierCurveQ::rotateAgainst</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The shape that a rotation against will be checked for 'blocks'.  </td></tr>
    <tr><td class="paramname">fulcrum</td><td>The fulcrum of the rotation.  </td></tr>
    <tr><td class="paramname">clockwise</td><td>The direction of the rotation.  </td></tr>
    <tr><td class="paramname">output</td><td>The destination for the calculated results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f49fbe2008de22b410872a5bcbe526f" name="a9f49fbe2008de22b410872a5bcbe526f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f49fbe2008de22b410872a5bcbe526f">&#9670;&#160;</a></span>rotateAgainstAfterRotating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::Shape::rotateAgainstAfterRotating </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputBeforeMove</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputRotationAngle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputRotationFulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inputRotationClockwise</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>myRotationFulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>myRotationClockwise</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate being 'pushed out of the way' by another shape's rotation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a20dd163770d993a80c75d32d6a65c21e" title="Simulate being &#39;pushed out of the way&#39; by another shape&#39;s shift.">Shape::shiftAgainstAfterShifting</a> </dd>
<dd>
<a class="el" href="group___directional_logic.html">Directional Terminology</a> </dd>
<dd>
<a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The angle to reverse a previous rotation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputBeforeMove</td><td>The pushing shape before it started the movement for which this shape was pushed.  </td></tr>
    <tr><td class="paramname">inputRotationAngle</td><td>The angle (in degrees) that the pushing shape will rotate. In the range [0, 360].  </td></tr>
    <tr><td class="paramname">inputRotationFulcrum</td><td>The fulcrum that the pushing curve will rotate around.  </td></tr>
    <tr><td class="paramname">inputRotationClockwise</td><td>True if the pushing curve is rotating clockwise.  </td></tr>
    <tr><td class="paramname">myRotationFulcrum</td><td>The point that this shape was rotated about as it was 'pushed'.  </td></tr>
    <tr><td class="paramname">myRotationClockwise</td><td>True if this shape was 'pushed' in a clockwise direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51b04b58bb5a060c98356ebb8eb2da68" name="a51b04b58bb5a060c98356ebb8eb2da68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b04b58bb5a060c98356ebb8eb2da68">&#9670;&#160;</a></span>rotateAgainstAfterShifting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::Shape::rotateAgainstAfterShifting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputBeforeMove</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputShiftDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputShiftSlope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inputShiftRight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inputShiftUp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>myRotationFulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>myRotationClockwise</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate being 'pushed out of the way' by another shape's shift. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a20dd163770d993a80c75d32d6a65c21e" title="Simulate being &#39;pushed out of the way&#39; by another shape&#39;s shift.">Shape::shiftAgainstAfterShifting</a> </dd>
<dd>
<a class="el" href="group___directional_logic.html">Directional Terminology</a> </dd>
<dd>
<a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The angle to reverse a previous rotation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputBeforeMove</td><td>The pushing shape before it started the movement for which this shape was pushed.  </td></tr>
    <tr><td class="paramname">inputShiftDistance</td><td>The distance that the pushing shape will move.  </td></tr>
    <tr><td class="paramname">inputShiftSlope</td><td>The slope that the pushing shape will move.  </td></tr>
    <tr><td class="paramname">inputShiftRight</td><td>The direction that the pushing shape will move along its slope.  </td></tr>
    <tr><td class="paramname">inputShiftUp</td><td>The direction that the pushing shape will move along its slope. Only used if the slope is very large.  </td></tr>
    <tr><td class="paramname">myRotationFulcrum</td><td>The point that this curve was rotated around as it was 'pushed'.  </td></tr>
    <tr><td class="paramname">myRotationClockwise</td><td>True if this curve was rotated clockwise as it was 'pushed'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4291c69a38b7eafba18a9a66b02ddb26" name="a4291c69a38b7eafba18a9a66b02ddb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4291c69a38b7eafba18a9a66b02ddb26">&#9670;&#160;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> bezier_geometry::Shape::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>distance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>up</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a version of this shape resulting from a straight line shift. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_point2_d.html#afd4102c24a4ac60946e2ca03567d8d9b" title="Get the result of moving this point by a given distance and direction.">Point2D::shift</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Another shape that results from moving this shape in a straight line. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance</td><td>The straight-line distance to be moved.  </td></tr>
    <tr><td class="paramname">slope</td><td>The slope along which the movement is to be calculated.  </td></tr>
    <tr><td class="paramname">right</td><td>The direction along the input slope.  </td></tr>
    <tr><td class="paramname">up</td><td>The direction along the input slope, only used if the slope is very large. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5839650a00c67b9f8b35ce0fc2631cc7" name="a5839650a00c67b9f8b35ce0fc2631cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5839650a00c67b9f8b35ce0fc2631cc7">&#9670;&#160;</a></span>shiftAgainst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bezier_geometry::Shape::shiftAgainst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>right</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>up</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbezier__geometry_1_1_shape_1_1_shift_against_result.html">Shape::ShiftAgainstResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the distance that this shape can be shifted until it 'hits' the input shape. </p>
<p>Given a shift direction, calculate how far this shape can be moved in a straight line until it is 'blocked' by the input shape. This is effectively an aggregate of the same method for individual curves, with some optimization around relevant intervals for a given direction. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html#a1fafc7198ad4394e07d3c64cbee8a621" title="Calculate the distance that this curve can be shifted until it &#39;hits&#39; the input curve.">BezierCurveQ::shiftAgainst</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The shape that a shift against will be checked for 'blocks'.  </td></tr>
    <tr><td class="paramname">slope</td><td>The slope along which the movement is to be calculated.  </td></tr>
    <tr><td class="paramname">right</td><td>The direction along the input slope.  </td></tr>
    <tr><td class="paramname">up</td><td>The direction along the input slope, only used if the slope is very large.  </td></tr>
    <tr><td class="paramname">output</td><td>The destination for the calculated results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad34039c8e4527f093c5f9fcb130dc821" name="ad34039c8e4527f093c5f9fcb130dc821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34039c8e4527f093c5f9fcb130dc821">&#9670;&#160;</a></span>shiftAgainstAfterRotating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::Shape::shiftAgainstAfterRotating </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputBeforeMove</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputRotationAngle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputRotationFulcrum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inputRotationClockwise</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>myShiftSlope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>myShiftRight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>myShiftUp</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate being 'pushed out of the way' by another shape's rotation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a20dd163770d993a80c75d32d6a65c21e" title="Simulate being &#39;pushed out of the way&#39; by another shape&#39;s shift.">Shape::shiftAgainstAfterShifting</a> </dd>
<dd>
<a class="el" href="group___directional_logic.html">Directional Terminology</a> </dd>
<dd>
<a class="el" href="group___clockwise_logic.html">Clockwise Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The distance to reverse a previous shift. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputBeforeMove</td><td>The pushing shape before it started the movement for which this shape was pushed.  </td></tr>
    <tr><td class="paramname">inputRotationAngle</td><td>The angle (in degrees) that the pushing shape will rotate. In the range [0, 360].  </td></tr>
    <tr><td class="paramname">inputRotationFulcrum</td><td>The fulcrum that the pushing curve will rotate around.  </td></tr>
    <tr><td class="paramname">inputRotationClockwise</td><td>True if the pushing curve is rotating clockwise.  </td></tr>
    <tr><td class="paramname">myShiftSlope</td><td>The slope that this shape was 'pushed' to move out of the way.  </td></tr>
    <tr><td class="paramname">myShiftRight</td><td>The direction along the slope that this shape was 'pushed' to move out of the way.  </td></tr>
    <tr><td class="paramname">myShiftUp</td><td>The direction along the slope that this shape was 'pushed' to move out of the way. Only used if the slope is very large. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20dd163770d993a80c75d32d6a65c21e" name="a20dd163770d993a80c75d32d6a65c21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20dd163770d993a80c75d32d6a65c21e">&#9670;&#160;</a></span>shiftAgainstAfterShifting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> bezier_geometry::Shape::shiftAgainstAfterShifting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbezier__geometry_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputBeforeMove</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputShiftDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputShiftSlope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inputShiftRight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>inputShiftUp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_bezier_geometry_global_8hpp.html#a00cdfbcccc2c4c9e46b95318dca1601c">RealNum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>myShiftSlope</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>myShiftRight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>myShiftUp</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate being 'pushed out of the way' by another shape's shift. </p>
<p>This is a very specialized function related to a particular physics simulation implementation.</p>
<p>If this shape was moved out of the way due to another shape's movement and the distance that this shape was moved was a guess, calculate how far to reverse the guess after the the other shape has completed its movement. The result of compensating by the amount indicated by this function is that this shape would appear to have been moved sufficiently to allow for the input shape's movement by a perfect amount. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___directional_logic.html">Directional Terminology</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The distance to reverse a previous shift. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputBeforeMove</td><td>The pushing shape before it started the movement for which this shape was pushed.  </td></tr>
    <tr><td class="paramname">inputShiftDistance</td><td>The distance that the pushing shape will move.  </td></tr>
    <tr><td class="paramname">inputShiftSlope</td><td>The slope that the pushing shape will move.  </td></tr>
    <tr><td class="paramname">inputShiftRight</td><td>The direction that the pushing shape will move along its slope.  </td></tr>
    <tr><td class="paramname">inputShiftUp</td><td>The direction that the pushing shape will move along its slope. Only used if the slope is very large.  </td></tr>
    <tr><td class="paramname">myShiftSlope</td><td>The slope that this shape was 'pushed' to move out of the way.  </td></tr>
    <tr><td class="paramname">myShiftRight</td><td>The direction along the slope that this shape was 'pushed' to move out of the way.  </td></tr>
    <tr><td class="paramname">myShiftUp</td><td>The direction along the slope that this shape was 'pushed' to move out of the way. Only used if the slope is very large. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb79c784f40959917bcceae803f88205" name="acb79c784f40959917bcceae803f88205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb79c784f40959917bcceae803f88205">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string bezier_geometry::Shape::toString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string representation of this shape. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classbezier__geometry_1_1_bezier_curve_q.html#a1f112b7cd9a321eb60b1181f0f37ee92" title="Get a string representation of this curve.">BezierCurveQ::toString</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing a comma-separated list of the edges in this shape. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_shape_8hpp_source.html">Shape.hpp</a></li>
<li><b>Shape.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
